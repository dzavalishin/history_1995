<HTML>
<HEAD>
<TITLE>Hypertext Transfer Protocol -- HTTP/1.0</TITLE>
<LINK rev=Made href="mailto:http-wg@cuckoo.hpl.hp.com">
</HEAD>
<BODY>
<PRE>
HTTP Working Group                                    T. Berners-Lee, MIT/LCS
INTERNET-DRAFT                                         R. Fielding, UC Irvine
&lt;draft-ietf-http-v10-spec-03.html&gt;                        H. Frystyk, MIT/LCS
Expires March 4, 1996                                       September 4, 1995
</PRE>

<CENTER>
<H1>Hypertext Transfer Protocol -- HTTP/1.0</H1>
</CENTER>
 
<H2>Status of this Memo</H2>
 
   This document is an Internet-Draft. Internet-Drafts are working documents of the Internet 
   Engineering Task Force (IETF), its areas, and its working groups. Note that other groups may 
   also distribute working documents as Internet-Drafts.
<P>

   Internet-Drafts are draft documents valid for a maximum of six months and may be updated, 
   replaced, or obsoleted by other documents at any time. It is inappropriate to use Internet-Drafts 
   as reference material or to cite them other than as "work in progress".
<P>

   To learn the current status of any Internet-Draft, please check the "<CODE>1id-abstracts.txt</CODE>" 
   listing contained in the Internet-Drafts Shadow Directories on <CODE>ftp.is.co.za</CODE> (Africa),<CODE> 
   nic.nordu.net</CODE> (Europe), <CODE>munnari.oz.au</CODE> (Pacific Rim), <CODE>ds.internic.net</CODE> (US East 
   Coast), or <CODE>ftp.isi.edu</CODE> (US West Coast).
<P>

   Distribution of this document is unlimited. Please send comments to the HTTP working group 
   at &lt;<CODE>http-wg@cuckoo.hpl.hp.com</CODE>&gt;. Discussions of the working group are archived at 
   &lt;<CODE>URL:http://www.ics.uci.edu/pub/ietf/http/</CODE>&gt;. General discussions about HTTP 
   and the applications which use HTTP should take place on the &lt;<CODE>www-talk@w3.org</CODE>&gt; mailing 
   list.
<P>

<H2>Abstract</H2>

   The Hypertext Transfer Protocol (HTTP) is an application-level protocol with the lightness and 
   speed necessary for distributed, collaborative, hypermedia information systems. It is a generic, 
   stateless, object-oriented protocol which can be used for many tasks, such as name servers and 
   distributed object management systems, through extension of its request methods (commands). 
   A feature of HTTP is the typing and negotiation of data representation, allowing systems to be 
   built independently of the data being transferred.
<P>

   HTTP has been in use by the World-Wide Web global information initiative since 1990. This 
   specification reflects common usage of the protocol referred to as "HTTP/1.0".
<P>

<H2>Table of Contents</H2>
 
<PRE>
<A HREF="#Introduction">1.  Introduction</A>
    <A HREF="#Purpose">1.1  Purpose</A>
    <A HREF="#Operation">1.2  Overall Operation</A>
    <A HREF="#Terminology">1.3  Terminology</A>
 
<A HREF="#Grammar">2.  Notational Conventions and Generic Grammar</A>
    <A HREF="#Augmented-BNF">2.1  Augmented BNF</A>
    <A HREF="#Basic-Rules">2.2  Basic Rules</A>
 
<A HREF="#Protocol-Parameters">3.  Protocol Parameters</A>
    <A HREF="#HTTP-Version">3.1  HTTP Version</A>
    <A HREF="#URI">3.2  Uniform Resource Identifiers</A>
         <A HREF="#URI-syntax">3.2.1 General Syntax</A>
         <A HREF="#http-URL">3.2.2 http URL</A>
    <A HREF="#DateFormats">3.3  Date/Time Formats</A>
    <A HREF="#Charset">3.4  Character Sets</A>
    <A HREF="#Content-Codings">3.5  Content Codings</A>
    <A HREF="#Media-Types">3.6  Media Types</A>
         <A HREF="#TextCanonicalization">3.6.1 Canonicalization and Text Defaults</A>
         <A HREF="#Multipart">3.6.2 Multipart Types</A>
    <A HREF="#Product">3.7  Product Tokens</A>
 
<A HREF="#Message">4.  HTTP Message</A>
    <A HREF="#Message-Types">4.1  Message Types</A>
    <A HREF="#Message-Headers">4.2  Message Headers</A>
    <A HREF="#General-Header">4.3  General Message Header Fields</A>
 
<A HREF="#Request">5. Request</A>
    <A HREF="#Request-Line">5.1  Request-Line</A>
    <A HREF="#Method">5.2  Method</A>
         <A HREF="#GET">5.2.1 GET</A>
         <A HREF="#HEAD">5.2.2 HEAD</A>
         <A HREF="#POST">5.2.3 POST</A>
    <A HREF="#Request-URI">5.3  Request-URI</A>
    <A HREF="#Request-Header">5.4  Request Header Fields</A>
 
<A HREF="#Response">6.  Response</A>
    <A HREF="#Status-Line">6.1  Status-Line</A>
    <A HREF="#Status-Codes">6.2  Status Codes and Reason Phrases</A>
         <A HREF="#Code1xx">6.2.1 Informational 1xx</A>
 <A HREF="#Code2xx">6.2.2 Successful 2xx</A>
               <A HREF="#Code200">200 OK</A>
               <A HREF="#Code201">201 Created</A>
               <A HREF="#Code202">202 Accepted</A>
               <A HREF="#Code204">204 No Content</A>
         <A HREF="#Code3xx">6.2.3 Redirection 3xx</A>
               <A HREF="#Code300">300 Multiple Choices</A>
               <A HREF="#Code301">301 Moved Permanently</A>
               <A HREF="#Code302">302 Moved Temporarily</A>
               <A HREF="#Code304">304 Not Modified</A>
         <A HREF="#Code4xx">6.2.4 Client Error 4xx</A>
               <A HREF="#Code400">400 Bad Request</A>
               <A HREF="#Code401">401 Unauthorized</A>
               <A HREF="#Code403">403 Forbidden</A>
               <A HREF="#Code404">404 Not Found</A>
         <A HREF="#Code5xx">6.2.5 Server Errors 5xx</A>
               <A HREF="#Code500">500 Internal Server Error</A>
               <A HREF="#Code501">501 Not Implemented</A>
               <A HREF="#Code502">502 Bad Gateway</A>
               <A HREF="#Code503">503 Service Unavailable</A>
    <A HREF="#Response-Header">6.3  Response Header Fields</A>
 
<A HREF="#Entity">7.  Entity</A>
    <A HREF="#Entity-Header">7.1  Entity Header Fields</A>
    <A HREF="#Entity-Body">7.2  Entity Body</A>
         <A HREF="#BodyType">7.2.1 Type</A>
         <A HREF="#BodyLength">7.2.2 Length</A>
 
<A HREF="#HeaderFields">8.  Header Field Definitions</A>
    <A HREF="#Allow">8.1  Allow</A>
    <A HREF="#Authorization">8.2  Authorization</A>
    <A HREF="#Content-Encoding">8.3  Content-Encoding</A>
    <A HREF="#Content-Length">8.4  Content-Length</A>
    <A HREF="#Content-Type">8.5  Content-Type</A>
    <A HREF="#Date">8.6  Date</A>
    <A HREF="#Expires">8.7  Expires</A>
    <A HREF="#From">8.8  From</A>
    <A HREF="#If-Modified-Since">8.9  If-Modified-Since</A>
    <A HREF="#Last-Modified">8.10  Last-Modified</A>
    <A HREF="#Location">8.11  Location</A>
    <A HREF="#MIME-Version">8.12  MIME-Version</A>
    <A HREF="#Pragma">8.13  Pragma</A>
    <A HREF="#Referer">8.14  Referer</A>
    <A HREF="#Server">8.15  Server</A>
    <A HREF="#User-Agent">8.16  User-Agent</A>
    <A HREF="#WWW-Authenticate">8.17  WWW-Authenticate</A>
 
<A HREF="#AA">9. Access Authentication</A>
    <A HREF="#BasicAA">9.1  Basic Authentication Scheme</A>
 
<A HREF="#Security">10. Security Considerations</A>
    <A HREF="#AuthSecurity">10.1  Authentication of Clients</A>
    <A HREF="#SafeMethods">10.2  Safe Methods</A>
    <A HREF="#LogAbuse">10.3  Abuse of Server Log Information</A>
    <A HREF="#Sensitive">10.4  Transfer of Sensitive Information</A>
 
<A HREF="#Acknowledgments">11. Acknowledgments</A>
 
<A HREF="#References">12. References</A>
 
<A HREF="#Authors">13. Authors' Addresses</A>
 
<A HREF="#Appendices">Appendices</A>
    <A HREF="#message_http">A.  Internet Media Type message/http</A>
    <A HREF="#Tolerant">B.  Tolerant Applications</A>
    <A HREF="#MIME">C.  Relationship to MIME</A>
        <A HREF="#MIME-Canonical">C.1  Conversion to Canonical Form</A>
             <A HREF="#MIME-LineBreaks">C.1.1 Representation of Line Breaks</A>
             <A HREF="#MIME-Charset">C.1.2 Default Character Set</A>
        <A HREF="#MIME-Date">C.2  Conversion of Date Formats</A>
        <A HREF="#MIME-CE">C.3  Introduction of Content-Encoding</A>
        <A HREF="#MIME-CTE">C.4  No Content-Transfer-Encoding</A>
</PRE>


<H2>1.  <a NAME="Introduction">Introduction</a></H2>

<H3>1.1  <A NAME="Purpose">Purpose</A></H3>

   The Hypertext Transfer Protocol (HTTP) is an application-level protocol with the lightness and 
   speed necessary for distributed, collaborative, hypermedia information systems. HTTP has 
   been in use by the World-Wide Web global information initiative since 1990. This specification 
   reflects common usage of the protocol referred to as "HTTP/1.0". This specification is not 
   intended to become an Internet standard; rather, it defines those features of the HTTP protocol 
   that can reasonably be expected of any implementation which claims to be using HTTP/1.0.
<P>

   Practical information systems require more functionality than simple retrieval, including 
   search, front-end update, and annotation. HTTP/1.0 allows an open-ended set of methods to be 
   used to indicate the purpose of a request. It builds on the discipline of reference provided by 
   the Uniform Resource Identifier (URI)<A HREF="#70197"> [2]</A>, as a location (URL)<A HREF="#70760"> [4]</A> or name (URN)<A HREF="#15237"> [16]</A>, for 
   indicating the resource on which a method is to be applied. Messages are passed in a format 
   similar to that used by Internet Mail<A HREF="#96313"> [7]</A> and the Multipurpose Internet Mail Extensions 
   (MIME)<A HREF="#54643"> [5]</A>.
<P>

   HTTP/1.0 is also used for communication between user agents and various gateways, allowing 
   hypermedia access to existing Internet protocols like SMTP<A HREF="#67282"> [12]</A>, NNTP<A HREF="#41656"> [11]</A>, FTP<A HREF="#94364"> [14]</A>, 
   Gopher<A HREF="#81090"> [1]</A>, and WAIS<A HREF="#21509"> [8]</A>. HTTP/1.0 is designed to allow such gateways, via proxy servers, 
   without any loss of the data conveyed by those earlier protocols.
<P>

<H3>1.2  <A NAME="Operation">Overall Operation</A></H3>

   The HTTP protocol is based on a request/response paradigm. A requesting program (termed a 
   client) establishes a connection with a receiving program (termed a server) and sends a request 
   to the server in the form of a request method, URI, and protocol version, followed by a
   MIME-like message containing request modifiers, client information, and possible body content. The 
   server responds with a status line, including its protocol version and a success or error code, 
   followed by a MIME-like message containing server information, entity metainformation, and 
   possible body content. It should be noted that a given program may be capable of being both a 
   client and a server; our use of those terms refers only to the role being performed by the 
   program during a particular connection, rather than to the program's purpose in general.
<P>

   On the Internet, the communication generally takes place over a TCP/IP connection. The 
   default port is TCP 80<A HREF="#22085"> [15]</A>, but other ports can be used. This does not preclude the HTTP/1.0 
   protocol from being implemented on top of any other protocol on the Internet, or on other 
   networks. HTTP only presumes a reliable transport; any protocol that provides such guarantees 
   can be used, and the mapping of the HTTP/1.0 request and response structures onto the 
   transport data units of the protocol in question is outside the scope of this specification.
<P>

   Current practice requires that the connection be established by the client prior to each request 
   and closed by the server after sending the response. Both clients and servers must be capable 
   of handling cases where either party closes the connection prematurely, due to user action, 
   automated time-out, or program failure. In any case, the closing of the connection by either or 
   both parties always terminates the current request, regardless of its status.
<P>

<H3>1.3  <A NAME="Terminology">Terminology</A></H3>

   This specification uses a number of terms to refer to the roles played by participants in, and 
   objects of, the HTTP communication.
<P>

<DL>
<DT>   <EM>connection</EM>
<DD>       A virtual circuit established between two parties for the purpose of communication.
<p>
<DT>   <EM>message</EM>
<DD>       A structured sequence of octets transmitted via the connection as the basic component of 
       communication.
<p>
<DT>   <EM>request</EM>
<DD>       An HTTP request message (as defined in <A HREF="#Request">Section 5</A>).
<p>
<DT>   <EM>response</EM>
<DD>       An HTTP response message (as defined in <A HREF="#Response">Section 6</A>).
<p>
<DT>   <EM>resource</EM>
<DD>       A network data object or service which can be identified by a URI (<A HREF="#URI">Section 3.2</A>).
<p>
<DT>   <EM>entity</EM>
<DD>       A particular representation or rendition of a resource that may be enclosed within a request 
       or response message. An entity consists of metainformation in the form of entity headers 
       and content in the form of an entity body.
<p>
<DT>   <EM>client</EM>
<DD>       A program that establishes connections for the purpose of sending requests.
<p>
<DT>   <EM>user agent</EM>
<DD>       The client program which is closest to the user and which initiates requests at their behest. 
       These are often browsers, editors, spiders (web-traversing robots), or other end user tools.
<p>
<DT>   <EM>server</EM>
<DD>       A program that accepts connections in order to service requests by sending back responses.
<p>
<DT>   <EM>origin server</EM>
<DD>       The server on which a given resource resides or is to be created.
<p>
<DT>   <EM>proxy</EM>
<DD>       An intermediary program which acts as both a server and a client for the purpose of 
       forwarding requests. Proxies are often used to act as a portal through a network firewall. A 
       <EM>proxy server</EM> accepts requests from other clients and services them either internally or by 
       passing them, with possible translation, on to other servers. A <EM>caching proxy</EM> is a proxy 
       server with a local cache of server responses -- some requested resources can be serviced 
       from the cache rather than from the origin server. Some proxy servers also act as origin 
       servers.
<p>
<DT>   <EM>gateway</EM>
<DD>       A proxy which services HTTP requests by translation into protocols other than HTTP. The 
       reply sent from the remote server to the gateway is likewise translated into HTTP before 
       being forwarded to the user agent.
</DL>

<H2>2.  <A NAME="Grammar">Notational Conventions and Generic Grammar</A></H2>

<H3>2.1  <A NAME="Augmented-BNF">Augmented BNF</A></H3>

   All of the mechanisms specified in this document are described in both prose and an augmented 
   Backus-Naur Form (BNF) similar to that used by RFC 822<A HREF="#96313"> [7]</A>. Implementors will need to be 
   familiar with the notation in order to understand this specification. The augmented BNF 
   includes the following constructs:
<P>

<DL>
<DT>   <CODE>name = definition</CODE>
<DD>       The name of a rule is simply the name itself (without any enclosing <CODE>"&lt;"</CODE> and <CODE>"&gt;"</CODE>) and is 
       separated from its definition by the equal character <CODE>"="</CODE>. Whitespace is only significant in 
       that indentation of continuation lines is used to indicate a rule definition that spans more 
       than one line. Certain basic rules are in uppercase, such as <CODE>SP</CODE>, <CODE>LWS</CODE>, <CODE>HT</CODE>, <CODE>CRLF</CODE>, <CODE>DIGIT</CODE>, 
       <CODE>ALPHA</CODE>, etc. Angle brackets are used within definitions whenever their presence will 
       facilitate discerning the use of rule names.
<p>
<DT>   <CODE>"literal"</CODE>
<DD>       Quotation marks surround literal text. Unless stated otherwise, the text is case-insensitive.
<p>
<DT>   <CODE>rule1 | rule2</CODE>
<DD>       Elements separated by a bar (<CODE>"I"</CODE>) are alternatives, e.g., "<CODE>yes | no</CODE>" will accept <CODE>yes</CODE> or <CODE>no</CODE>.
<p>
<DT>   <CODE>(rule1 rule2)</CODE>
<DD>       Elements enclosed in parentheses are treated as a single element. Thus,<BR>
       "<CODE>(elem (foo | bar) elem)</CODE>" allows the token sequences "<CODE>elem foo elem</CODE>" and "<CODE>elem bar elem</CODE>".
<p>
<DT>   <CODE>*rule</CODE>
<DD>       The character <CODE>"*"</CODE> preceding an element indicates repetition. The full form is 
       "<CODE>&lt;n&gt;*&lt;m&gt;element</CODE>" indicating at least <CODE>&lt;n&gt;</CODE> and at most <CODE>&lt;m&gt;</CODE> occurrences of <CODE>element</CODE>. Default 
       values are <CODE>0</CODE> and infinity so that "<CODE>*(element)</CODE>" allows any number, including zero; "<CODE>1*element</CODE>" 
       requires at least one; and "<CODE>1*2element</CODE>" allows one or two.
<p>
<DT>   <CODE>[rule]</CODE>
<DD>       Square brackets enclose optional elements; "<CODE>[foo bar]</CODE>" is equivalent to "<CODE>*1(foo bar)</CODE>".
<p>
<DT>   <EM>N</EM><CODE> rule</CODE>
<DD>       Specific repetition: "<CODE>&lt;n&gt;(element)</CODE>" is equivalent to "<CODE>&lt;n&gt;*&lt;n&gt;(element)</CODE>"; that is, exactly <CODE>&lt;n&gt;</CODE> 
       occurrences of <CODE>(element)</CODE>. Thus <CODE>2DIGIT</CODE> is a 2-digit number, and <CODE>3ALPHA</CODE> is a string of three 
       alphabetic characters.
<p>
<DT>   <CODE>#rule</CODE>
<DD>       A construct <CODE>"#"</CODE> is defined, similar to <CODE>"*"</CODE>, for defining lists of elements. The full form is 
       "<CODE>&lt;n&gt;#&lt;m&gt;element</CODE>" indicating at least <CODE>&lt;n&gt;</CODE> and at most <CODE>&lt;m&gt;</CODE> elements, each separated by one 
       or more commas (<CODE>","</CODE>) and optional linear whitespace (LWS). This makes the usual form of 
       lists very easy; a rule such as "<CODE>( *LWS element *( *LWS "," *LWS element ))</CODE>" can be shown as 
       "<CODE>1#element</CODE>". Wherever this construct is used, null elements are allowed, but do not 
       contribute to the count of elements present. That is, "<CODE>(element), , (element)</CODE>" is permitted, but 
       counts as only two elements. Therefore, where at least one element is required, at least one 
       non-null element must be present. Default values are <CODE>0</CODE> and infinity so that "<CODE>#(element)</CODE>" 
       allows any number, including zero; "<CODE>1#element</CODE>" requires at least one; and "<CODE>1#2element</CODE>" 
       allows one or two.
<p>
<DT>   <CODE>; comment</CODE>
<DD>       A semi-colon, set off some distance to the right of rule text, starts a comment that continues 
       to the end of line. This is a simple way of including useful notes in parallel with the 
       specifications.
<p>
<DT>   <CODE>implied *LWS</CODE>
<DD>       The grammar described by this specification is word-based. Except where noted otherwise, 
       zero or more linear whitespace (<CODE>LWS</CODE>) can be included between any two adjacent words 
       (<CODE>token</CODE> or <CODE>quoted-string</CODE>), and between adjacent tokens and delimiters (<CODE>tspecials</CODE>), without 
       changing the interpretation of a field. However, applications should attempt to follow 
       "common form" when generating HTTP constructs, since there exist some 
       implementations that fail to accept anything beyond the common forms.
</DL>

<H3>2.2  <A NAME="Basic-Rules">Basic Rules</A></H3>

   The following rules are used throughout this specification to describe basic parsing constructs. 
   The US-ASCII coded character set is defined by<A HREF="#29693"> [17]</A>.
<P>

<PRE>
       OCTET          = &lt;any 8-bit sequence of data&gt;
       CHAR           = &lt;any US-ASCII character (octets 0 - 127)&gt;
       UPALPHA        = &lt;any US-ASCII uppercase letter "A".."Z"&gt;
       LOALPHA        = &lt;any US-ASCII lowercase letter "a".."z"&gt;
       ALPHA          = UPALPHA | LOALPHA
       DIGIT          = &lt;any US-ASCII digit "0".."9"&gt;
       CTL            = &lt;any US-ASCII control character
                        (octets 0 - 31) and DEL (127)&gt;
       CR             = &lt;US-ASCII CR, carriage return (13)&gt;
       LF             = &lt;US-ASCII LF, linefeed (10)&gt;
       SP             = &lt;US-ASCII SP, space (32)&gt;
       HT             = &lt;US-ASCII HT, horizontal-tab (9)&gt;
       &lt;"&gt;            = &lt;US-ASCII double-quote mark (34)&gt;
</PRE>

   HTTP/1.0 defines the octet sequence <CODE>CR LF</CODE> as the end-of-line marker for all protocol elements 
   except the <CODE>Entity-Body</CODE> (see <A HREF="#Tolerant">Appendix B</A> for tolerant applications). The end-of-line marker 
   within an <CODE>Entity-Body</CODE> is defined by its associated media type, as described in <A HREF="#Media-Types">Section 3.6</A>.
<P>

<PRE>
       CRLF           = CR LF
</PRE>

   HTTP/1.0 headers may be folded onto multiple lines if the continuation lines begin with linear 
   whitespace characters. All linear whitespace, including folding, has the same semantics as <CODE>SP</CODE>.
<P>

<PRE>
       LWS            = [CRLF] 1*( SP | HT )
</PRE>

   However, folding of header lines is not expected by some applications, and should not be 
   generated by HTTP/1.0 applications.
<P>

   Many HTTP/1.0 header field values consist of words separated by <CODE>LWS</CODE> or special characters. 
   These special characters must be in a quoted string to be used within a parameter value.
<P>

<PRE>
       word           = token | quoted-string
</PRE>

<PRE>
       token          = 1*&lt;any CHAR except CTLs or tspecials&gt;
</PRE>

<PRE>
       tspecials      = "(" | ")" | "&lt;" | "&gt;" | "@"
                      | "," | ";" | ":" | "\" | &lt;"&gt;
                      | "/" | "[" | "]" | "?" | "="
                      | "{" | "}" | SP | HT
</PRE>

   Comments may be included in some HTTP header fields by surrounding the comment text with 
   parentheses. Comments are only allowed in fields containing "<CODE>comment</CODE>" as part of their field 
   value definition.
<P>

<PRE>
       comment        = "(" *( ctext | comment ) ")"
       ctext          = &lt;any text excluding "(" and ")"&gt;
</PRE>

   A string of text is parsed as a single word if it is quoted using double-quote marks.
<P>

<PRE>
       quoted-string  = ( &lt;"&gt; *(qdtext) &lt;"&gt; )
</PRE>

<PRE>
       qdtext         = &lt;any CHAR except &lt;"&gt; and CTLs,
                        but including LWS&gt;
</PRE>

   Single-character quoting using the backslash ("\") character is not permitted in HTTP/1.0.
<P>

   The text rule is only used for descriptive field contents and values that are not intended to be 
   interpreted by the message parser. Words of <CODE>*text</CODE> may contain octets from character sets other 
   than US-ASCII.
<P>

<PRE>
       text           = &lt;any OCTET except CTLs,
                        but including LWS&gt;
</PRE>

   Recipients of header field text containing octets outside the US-ASCII character set may 
   assume that they represent ISO-8859-1 characters.
<P>

<H2>3.  <A NAME="Protocol-Parameters">Protocol Parameters</A></H2>

<H3>3.1  <A NAME="HTTP-Version">HTTP Version</A></H3>

   HTTP uses a "&lt;major&gt;.&lt;minor&gt;" numbering scheme to indicate versions of the protocol. The 
   protocol versioning policy is intended to allow the sender to indicate the format of a message 
   and its capacity for understanding further HTTP communication, rather than the features 
   obtained via that communication. No change is made to the version number for the addition of 
   message components which do not affect communication behavior or which only add to 
   extensible field values. The &lt;minor&gt; number is incremented when the changes made to the 
   protocol add features which do not change the general message parsing algorithm, but which 
   may add to the message semantics and imply additional capabilities of the sender. The &lt;major&gt; 
   number is incremented when the format of a message within the protocol is changed.
<P>

   The version of an HTTP message is indicated by an <CODE>HTTP-Version</CODE> field in the first line of the 
   message. If the protocol version is not specified, the recipient must assume that the message is 
   in the simple HTTP/0.9 format.
<P>

<PRE>
       HTTP-Version   = "HTTP" "/" 1*DIGIT "." 1*DIGIT
</PRE>

   Note that the major and minor numbers should be treated as separate integers and that each may 
   be incremented higher than a single digit. Thus, HTTP/2.4 is a lower version than HTTP/2.13, 
   which in turn is lower than HTTP/12.3. Leading zeros should be ignored by recipients and 
   never generated by senders.
<P>

   This document defines both the 0.9 and 1.0 versions of the HTTP protocol. Applications 
   sending <CODE>Full-Request</CODE> or <CODE>Full-Response</CODE> messages, as defined by this specification, must include 
   an <CODE>HTTP-Version</CODE> of "<CODE>HTTP/1.0</CODE>".
<P>

   HTTP/1.0 servers must:
<UL>
<LI>       recognize the format of the <CODE>Request-Line</CODE> for HTTP/0.9 and HTTP/1.0 requests;
<LI>       understand any valid request in the format of HTTP/0.9 or HTTP/1.0;
<LI>       respond appropriately with a message in the same protocol version used by the client.
</UL>
<P>
   HTTP/1.0 clients must:

<UL>
<LI>       recognize the format of the <CODE>Status-Line</CODE> for HTTP/1.0 responses;
<LI>       understand any valid response in the format of HTTP/0.9 or HTTP/1.0.
</UL>
   Proxies must be careful in forwarding requests that are received in a format different than that 
   of the proxy's native version. Since the protocol version indicates the protocol capability of the 
   sender, a proxy must never send a message with a version indicator which is greater than its 
   native version; if a higher version request is received, the proxy must either downgrade the 
   request version or respond with an error. Requests with a version lower than that of the proxy's 
   native format may be upgraded by the proxy before being forwarded; the proxy's response to 
   that request must follow the normal server requirements.
<P>

<H3>3.2  <A NAME="URI">Uniform Resource Identifiers</A></H3>

   URIs have been known by many names: WWW addresses, Universal Document Identifiers, 
   Universal Resource Identifiers<A HREF="#70197"> [2]</A>, and finally the combination of Uniform Resource Locators 
   (URL)<A HREF="#70760"> [4]</A> and Names (URN)<A HREF="#15237"> [16]</A>. As far as HTTP is concerned, Uniform Resource Identifiers 
   are simply formatted strings which identify--via name, location, or any other characteristic--
   a network resource.

<H4>3.2.1 <A NAME="URI-syntax">General Syntax</A></H4>

   URIs in HTTP/1.0 can be represented in absolute form or relative to some known base 
   URI<A HREF="#55040"> [9]</A>, depending upon the context of their use. The two forms are differentiated by the fact 
   that absolute URIs always begin with a scheme name followed by a colon.

<PRE>
       URI            = ( absoluteURI | relativeURI ) [ "#" fragment ]
</PRE>

<PRE>
       absoluteURI    = scheme ":" *( uchar | reserved )
</PRE>

<PRE>
       relativeURI    = net_path | abs_path | rel_path
</PRE>

<PRE>
       net_path       = "//" net_loc [ abs_path ]
       abs_path       = "/" rel_path
       rel_path       = [ path ] [ ";" params ] [ "?" query ]
</PRE>

<PRE>
       path           = fsegment *( "/" segment )
       fsegment       = 1*pchar
       segment        = *pchar
</PRE>

<PRE>
       params         = param *( ";" param )
       param          = *( pchar | "/" )
</PRE>

<PRE>
       scheme         = 1*( ALPHA | DIGIT | "+" | "-" | "." )
       net_loc        = *( pchar | ";" | "?" )
       query          = *( uchar | reserved )
       fragment       = *( uchar | reserved )
</PRE>

<PRE>
       pchar          = uchar | ":" | "@" | "&amp;" | "="
       uchar          = unreserved | escape
       unreserved     = ALPHA | DIGIT | safe | extra | national
</PRE>

<PRE>
       escape         = "%" hex hex
       hex            = "A" | "B" | "C" | "D" | "E" | "F"
                      | "a" | "b" | "c" | "d" | "e" | "f" | DIGIT
</PRE>

<PRE>
       reserved       = ";" | "/" | "?" | ":" | "@" | "&amp;" | "="
       safe           = "$" | "-" | "_" | "." | "+"
       extra          = "!" | "*" | "'" | "(" | ")" | ","
       national       = &lt;any OCTET excluding CTLs, SP,
                         ALPHA, DIGIT, reserved, safe, and extra&gt;
</PRE>

   For definitive information on URL syntax and semantics, see RFC 1738<A HREF="#70760"> [4]</A> and RFC 1808<A HREF="#55040"> [9]</A>. 
   The BNF above includes <CODE>national</CODE> characters not allowed in valid URLs as specified by RFC 
   1738, since HTTP servers are not restricted in the set of <CODE>unreserved</CODE> characters allowed to 
   represent the <CODE>rel_path</CODE> part of addresses, and HTTP proxies may receive requests for URIs not 
   defined by RFC 1738.
<P>

<H4>3.2.2 <A NAME="http-URL">http URL</A></H4>

   The "http" scheme is used to locate network resources via the HTTP protocol. This section 
   defines the scheme-specific syntax and semantics for http URLs.
<P>

<PRE>
       http_URL       = "http:" "//" host [ ":" port ] abs_path
</PRE>

<PRE>
       host           = &lt;FQDN or IP address, as defined in RFC 1738&gt;
       port           = *DIGIT
</PRE>

   If the <CODE>port</CODE> is empty or not given, port 80 is assumed. The semantics are that the identified 
   resource is located at the server listening for TCP connections on that <CODE>port</CODE> of that <CODE>host</CODE>, and the 
   <CODE>Request-URI</CODE> for the resource is <CODE>abs_path</CODE>. If the <CODE>abs_path</CODE> is not present in the URL, it must be 
   given as "/" when used as a <CODE>Request-URI</CODE>.
<P>

   The canonical form for "http" URLs is obtained by converting any <CODE>UPALPHA</CODE> characters in <CODE>host</CODE> 
   to their <CODE>LOALPHA</CODE> equivalent (hostnames are case-insensitive), eliding the <CODE>[ ":" port ]</CODE> if the port 
   is 80, and replacing an empty <CODE>abs_path</CODE> with "/".
<P>

<H3>3.3  <A NAME="DateFormats">Date/Time Formats</A></H3>

   HTTP/1.0 applications have historically allowed three different formats for the representation 
   of date/time stamps:
<P>

<PRE>
       Sun, 06 Nov 1994 08:49:37 GMT     ; RFC 822, updated by RFC 1123
       Sunday, 06-Nov-94 08:49:37 GMT    ; RFC 850, obsoleted by RFC 1036
       Sun Nov  6 08:49:37 1994          ; ANSI C's asctime() format
</PRE>

   The first format is preferred as an Internet standard and represents a fixed-length subset of that 
   defined by RFC 1123<A HREF="#40086"> [6]</A> (an update to RFC 822<A HREF="#96313"> [7]</A>). The second format is in common use, but 
   is based on the obsolete RFC 850<A HREF="#29505"> [10]</A> date format and lacks a four-digit year. HTTP/1.0 clients 
   and servers that parse the date value should accept all three formats, though they must never 
   generate the third (asctime) format.
<P>

<BLOCKQUOTE>
       Note: Recipients of date values are encouraged to be robust in accepting date values 
       that may have been generated by non-HTTP applications, as is sometimes the case 
       when retrieving or posting messages via gateways to SMTP or NNTP.
</BLOCKQUOTE>

   All HTTP/1.0 date/time stamps must be represented in Universal Time (UT), also known as 
   Greenwich Mean Time (GMT), without exception. This is indicated in the first two formats by 
   the inclusion of "GMT" as the three-letter abbreviation for time zone, and should be assumed 
   when reading the asctime format.
<P>

<PRE>
       HTTP-date      = rfc1123-date | rfc850-date | asctime-date
</PRE>

<PRE>
       rfc1123-date   = wkday "," SP date1 SP time SP "GMT"
       rfc850-date    = weekday "," SP date2 SP time SP "GMT"
       asctime-date   = wkday SP date3 SP time SP 4DIGIT
</PRE>

<PRE>
       date1          = 2DIGIT SP month SP 4DIGIT
                        ; day month year (e.g., 02 Jun 1982)
       date2          = 2DIGIT "-" month "-" 2DIGIT
                        ; day-month-year (e.g., 02-Jun-82)
       date3          = month SP ( 2DIGIT | ( SP 1DIGIT ))
                        ; month day (e.g., Jun  2)
</PRE>

<PRE>
       time           = 2DIGIT ":" 2DIGIT ":" 2DIGIT
                        ; 00:00:00 - 23:59:59
</PRE>

<PRE>
       wkday          = "Mon" | "Tue" | "Wed"
                      | "Thu" | "Fri" | "Sat" | "Sun"
</PRE>

<PRE>
       weekday        = "Monday" | "Tuesday" | "Wednesday"
                      | "Thursday" | "Friday" | "Saturday" | "Sunday"
</PRE>

<PRE>
       month          = "Jan" | "Feb" | "Mar" | "Apr"
                      | "May" | "Jun" | "Jul" | "Aug"
                      | "Sep" | "Oct" | "Nov" | "Dec"
</PRE>

<BLOCKQUOTE>
       Note: HTTP/1.0 requirements for the date/time stamp format apply only to their 
       usage within the protocol stream. Clients and servers are not required to use these 
       formats for user presentation, request logging, etc.
</BLOCKQUOTE>

<H3>3.4  <A NAME="Charset">Character Sets</A></H3>

   HTTP uses the same definition of the term "character set" as that described for MIME:
<P>

<BLOCKQUOTE>
        The term "character set" is used in this document to refer to a method used with 
        one or more tables to convert a sequence of octets into a sequence of characters. 
        Note that unconditional conversion in the other direction is not required, in that 
        not all characters may be available in a given character set and a character set may 
        provide more than one sequence of octets to represent a particular character. This 
        definition is intended to allow various kinds of character encodings, from simple 
        single-table mappings such as US-ASCII to complex table switching methods 
        such as those that use ISO 2022's techniques. However, the definition associated 
        with a MIME character set name must fully specify the mapping to be performed 
        from octets to characters. In particular, use of external profiling information to 
        determine the exact mapping is not permitted.
</BLOCKQUOTE>

   HTTP character sets are identified by case-insensitive tokens. The complete set of tokens are 
   defined by the IANA Character Set registry<A HREF="#22085"> [15]</A>. However, because that registry does not 
   define a single, consistent token for each character set, we define here the preferred names for 
   those character sets most likely to be used with HTTP entities. These character sets include 
   those registered by RFC 1521<A HREF="#54643"> [5]</A> -- the US-ASCII<A HREF="#29693"> [17]</A> and ISO-8859<A HREF="#75289"> [18]</A> character sets -- 
   and other names specifically recommended for use within MIME charset parameters.
<P>

<PRE>
     charset = "US-ASCII"
             | "ISO-8859-1" | "ISO-8859-2" | "ISO-8859-3"
             | "ISO-8859-4" | "ISO-8859-5" | "ISO-8859-6"
             | "ISO-8859-7" | "ISO-8859-8" | "ISO-8859-9"
             | "ISO-2022-JP" | "ISO-2022-JP-2" | "ISO-2022-KR"
             | "UNICODE-1-1" | "UNICODE-1-1-UTF-7" | "UNICODE-1-1-UTF-8"
             | token
</PRE>

   Although HTTP allows an arbitrary token to be used as a charset value, any token that has a 
   predefined value within the IANA Character Set registry<A HREF="#22085"> [15]</A> must represent the character set 
   defined by that registry. Applications are encouraged, but not required, to limit their use of 
   character sets to those defined by the IANA registry.
<P>

<BLOCKQUOTE>
       Note: This use of the term "character set" is more commonly referred to as a 
       "character encoding." However, since HTTP and MIME share the same registry, it is 
       important that the terminology also be shared.
</BLOCKQUOTE>

<H3>3.5  <A NAME="Content-Codings">Content Codings</A></H3>

   Content coding values are used to indicate an encoding transformation that has been or can be 
   applied to a resource. Content codings are primarily used to allow a document to be compressed 
   or encrypted without losing the identity of its underlying media type. Typically, the resource is 
   stored in this encoding and only decoded before rendering or analogous usage.
<P>

<PRE>
       content-coding          = "x-gzip" | "x-compress" | token
</PRE>

<BLOCKQUOTE>
       Note: For future compatibility, HTTP/1.0 applications should consider "gzip" and 
       "compress" to be equivalent to "x-gzip" and "x-compress", respectively.
</BLOCKQUOTE>

   All <CODE>content-coding</CODE> values are case-insensitive. HTTP/1.0 uses <CODE>content-coding</CODE> values in the 
   <CODE>Content-Encoding</CODE> (<A HREF="#Content-Encoding">Section 8.3</A>) header field. Although the value describes the content-coding, 
   what is more important is that it indicates what decoding mechanism will be required to remove 
   the encoding. Note that a single program may be capable of decoding multiple content-coding 
   formats. Two values are defined by this specification:
<P>

<DL>
<DT>   <CODE>x-gzip
<DD>
       </CODE>An encoding format produced by the file compression program "gzip" (GNU zip) 
       developed by Jean-loup Gailly. This format is typically a Lempel-Ziv coding (LZ77) with 
       a 32 bit CRC. Gzip is available from the GNU project at 
       &lt;URL:ftp://prep.ai.mit.edu/pub/gnu/&gt;.
<p>
<DT>   <CODE>x-compress
<DD>
       </CODE>The encoding format produced by the file compression program "compress". This format 
       is an adaptive Lempel-Ziv-Welch coding (LZW).
</DL>

<BLOCKQUOTE>
       Note: Use of program names for the identification of encoding formats is not 
       desirable and should be discouraged for future encodings. Their use here is 
       representative of historical practice, not good design.
</BLOCKQUOTE>

<H3>3.6  <A NAME="Media-Types">Media Types</A></H3>

   HTTP uses Internet Media Types<A HREF="#35139"> [13]</A> (formerly referred to as MIME Content-Types<A HREF="#54643"> [5]</A>) in 
   order to provide open and extensible data typing and type negotiation. For mail applications, 
   where there is no type negotiation between sender and receiver, it is reasonable to put strict 
   limits on the set of allowed media types. With HTTP, where the sender and recipient can 
   communicate directly, applications are allowed more freedom in the use of non-registered 
   types. The following grammar for media types is a superset of that for MIME because it does 
   not restrict itself to the official IANA and x-token types.
<P>

<PRE>
       media-type     = type "/" subtype *( ";" parameter )
       type           = token
       subtype        = token
</PRE>

    Parameters may follow the type/subtype in the form of attribute/value pairs.
<P>

<PRE>
       parameter      = attribute "=" value
       attribute      = token
       value          = token | quoted-string
</PRE>

   The type, subtype, and parameter attribute names are case-insensitive. Parameter values may 
   or may not be case-sensitive, depending on the semantics of the parameter name. <CODE>LWS</CODE> must not 
   be generated between the type and subtype, nor between an attribute and its value.
<P>

   Many current applications do not recognize media type parameters. Since parameters are a 
   fundamental aspect of media types, this must be considered an error in those applications. 
   Nevertheless, HTTP/1.0 applications should only use media type parameters when they are 
   necessary to define the content of a message.
<P>

   If a given <CODE>media-type</CODE> value has been registered by the IANA, any use of that value must be 
   indicative of the registered data format. Although HTTP allows the use of non-registered media 
   types, such usage must not conflict with the IANA registry. Data providers are strongly 
   encouraged to register their media types with IANA via the procedures outlined in 
   RFC 1590<A HREF="#35139"> [13]</A>.
<P>

   All <CODE>media-type</CODE>'s registered by IANA must be preferred over extension tokens. However, HTTP 
   does not limit conforming applications to the use of officially registered media types, nor does 
   it encourage the use of an "<CODE>x-</CODE>" prefix for unofficial types outside of explicitly short 
   experimental use between consenting applications.
<P>

<H4>3.6.1 <A NAME="TextCanonicalization">Canonicalization and Text Defaults</A></H4>

   Media types are registered in a canonical form. In general, entity bodies transferred via HTTP 
   must be represented in the appropriate canonical form prior to transmission. If the body has 
   been encoded via a <CODE>Content-Encoding</CODE>, the data must be in canonical form prior to that encoding. 
   However, HTTP modifies the canonical form requirements for media of primary type "text" 
   and for "application" types consisting of text-like records.
<P>

   HTTP redefines the canonical form of text media to allow multiple octet sequences to indicate 
   a text line break. In addition to the preferred form of CRLF, HTTP applications must accept a 
   bare CR or LF alone as representing a single line break in text media. Furthermore, if the text 
   media is represented in a character set which does not use octets 13 and 10 for CR and LF 
   respectively, as is the case for some multi-byte character sets, HTTP allows the use of whatever 
   octet sequence(s) is defined by that character set to represent the equivalent of CRLF, bare CR, 
   and bare LF. It is assumed that any recipient capable of using such a character set will know 
   the appropriate octet sequence for representing line breaks within that character set.
<P>

<BLOCKQUOTE>
       Note: This interpretation of line breaks applies only to the contents of an Entity-Body 
       and only after any Content-Encoding has been removed. All other HTTP constructs 
       use CRLF exclusively to indicate a line break. Content codings define their own line 
       break requirements.
</BLOCKQUOTE>

   A recipient of an HTTP text entity should translate the received entity line breaks to the local 
   line break conventions before saving the entity external to the application and its cache; 
   whether this translation takes place immediately upon receipt of the entity, or only when 
   prompted by the user, is entirely up to the individual application.
<P>

   HTTP also redefines the default character set for text media in an entity body. If a textual media 
   type defines a charset parameter with a registered default value of "US-ASCII", HTTP changes 
   the default to be "ISO-8859-1". Since the ISO-8859-1<A HREF="#75289"> [18]</A> character set is a superset of 
   US-ASCII<A HREF="#29693"> [17]</A>, this has no effect upon the interpretation of entity bodies which only contain 
   octets within the US-ASCII set (0 - 127). The presence of a charset parameter value in a 
   <CODE>Content-Type</CODE> header field overrides the default.
<P>

   It is recommended that the character set of an entity body be labelled as the lowest common 
   denominator of the character codes used within a document, with the exception that no label is 
   preferred over the labels US-ASCII or ISO-8859-1.
<P>

<H4>3.6.2 <A NAME="Multipart">Multipart Types</A></H4>

   MIME provides for a number of "multipart" types -- encapsulations of several entities within 
   a single message's <CODE>Entity-Body</CODE>. The multipart types registered by IANA<A HREF="#22085"> [15]</A> do not have any 
   special meaning for HTTP/1.0, though user agents may need to understand each type in order 
   to correctly interpret the purpose of each body-part. Ideally, an HTTP user agent should follow 
   the same or similar behavior as a MIME user agent does upon receipt of a multipart type.
<P>

   As in MIME<A HREF="#54643"> [5]</A>, all multipart types share a common syntax and must include a boundary 
   parameter as part of the media type value. The message body is itself a protocol element and 
   must therefore use only <CODE>CRLF</CODE> to represent line breaks between body-parts. Unlike in MIME, 
   multipart body-parts may contain HTTP header fields which are significant to the meaning of 
   that part.
<P>

<H3>3.7  <A NAME="Product">Product Tokens</A></H3>

   Product tokens are used to allow communicating applications to identify themselves via a 
   simple product token, with an optional slash and version designator. Most fields using product 
   tokens also allow subproducts which form a significant part of the application to be listed, 
   separated by whitespace. By convention, the products are listed in order of their significance 
   for identifying the application.
<P>

<PRE>
       product         = token ["/" product-version]
       product-version = token
</PRE>

   Examples:
<P>

<PRE>
       User-Agent: CERN-LineMode/2.15 libwww/2.17b3
</PRE>

<PRE>
       Server: Apache/0.8.4
</PRE>

   Product tokens should be short and to the point -- use of them for advertizing or other
non-essential information is explicitly forbidden. Although any token character may appear in a 
   <CODE>product-version</CODE>, this token should only be used for a version identifier (i.e., successive versions 
   of the same product should only differ in the <CODE>product-version</CODE> portion of the <CODE>product</CODE> value).
<P>

<H2>4.  <A NAME="Message">HTTP Message</A></H2>

<H3>4.1  <A NAME="Message-Types">Message Types</A></H3>

   HTTP messages consist of requests from client to server and responses from server to client.
<P>

<PRE>
       HTTP-message   = Simple-Request            ; HTTP/0.9 messages
                      | Simple-Response
                      | Full-Request              ; HTTP/1.0 messages
                      | Full-Response
</PRE>

   <CODE>Full-Request</CODE> and <CODE>Full-Response</CODE> use the generic message format of RFC 822<A HREF="#96313"> [7]</A> for transferring 
   entities. Both messages may include optional header fields (a.k.a. "headers") and an entity 
   body. The entity body is separated from the headers by a null line (i.e., a line with nothing 
   preceding the <CODE>CRLF</CODE>).
<P>

<PRE>
       Full-Request   = Request-Line              ; <A HREF="#Request-Line">Section 5.1</A>
                        *( General-Header         ; <A HREF="#General-Header">Section 4.3</A>
                        |  Request-Header         ; <A HREF="#Request-Header">Section 5.4</A>
                        |  Entity-Header )        ; <A HREF="#Entity-Header">Section 7.1</A>
                        CRLF
                        [ Entity-Body ]           ; <A HREF="#Entity-Body">Section 7.2</A>
</PRE>

<PRE>
       Full-Response  = Status-Line               ; <A HREF="#Status-Line">Section 6.1</A>
                        *( General-Header         ; <A HREF="#General-Header">Section 4.3</A>
                        |  Response-Header        ; <A HREF="#Response-Header">Section 6.3</A>
                        |  Entity-Header )        ; <A HREF="#Entity-Header">Section 7.1</A>
                        CRLF
                        [ Entity-Body ]           ; <A HREF="#Entity-Body">Section 7.2</A>
</PRE>

   <CODE>Simple-Request</CODE> and <CODE>Simple-Response</CODE> do not allow the use of any header information and are 
   limited to a single request method (<CODE>GET</CODE>).
<P>

<PRE>
       Simple-Request  = "GET" SP Request-URI CRLF
</PRE>

<PRE>
       Simple-Response = [ Entity-Body ]
</PRE>

   Use of the <CODE>Simple-Request</CODE> format is discouraged because it prevents the server from identifying 
   the media type of the returned entity.
<P>

<H3>4.2  <A NAME="Message-Headers">Message Headers</A></H3>

   HTTP header fields, which include <CODE>General-Header</CODE> (<A HREF="#General-Header">Section 4.3</A>), <CODE>Request-Header</CODE> (<A HREF="#Request-Header">Section 5.4</A>), 
   <CODE>Response-Header</CODE> (<A HREF="#Response-Header">Section 6.3</A>), and <CODE>Entity-Header</CODE> (<A HREF="#Entity-Header">Section 7.1</A>) fields, follow the same generic 
   format as that given in Section 3.1 of RFC 822<A HREF="#96313"> [7]</A>. Each header field consists of a name 
   followed immediately by a colon (<CODE>":"</CODE>), a single space (<CODE>SP</CODE>) character, and the field value. Field 
   names are case-insensitive. Header fields can be extended over multiple lines by preceding 
   each extra line with at least one <CODE>LWS</CODE>, though this is not recommended.
<P>

<PRE>
       HTTP-header    = field-name ":" [ field-value ] CRLF
</PRE>

<PRE>
       field-name     = 1*&lt;any CHAR, excluding CTLs, SP, and ":"&gt;
       field-value    = *( field-content | LWS )
</PRE>

<PRE>
       field-content  = &lt;the OCTETs making up the field-value
                        and consisting of either *text or combinations
                        of token, tspecials, and quoted-string&gt;
</PRE>

   The order in which header fields are received is not significant. However, it is "good practice" 
   to send <CODE>General-Header</CODE> fields first, followed by <CODE>Request-Header</CODE> or <CODE>Response-Header</CODE> fields prior 
   to the <CODE>Entity-Header</CODE> fields.
<P>

   Multiple <CODE>HTTP-header</CODE> fields with the same <CODE>field-name</CODE> may be present in a message if and only 
   if the entire <CODE>field-value</CODE> for that header field is defined as a comma-separated list [i.e., <CODE>#(values)</CODE>]. 
   It must be possible to combine the multiple header fields into one "field-name: field-value" pair, 
   without changing the semantics of the message, by appending each subsequent field-value to 
   the first, each separated by a comma.
<P>

<H3>4.3  <A NAME="General-Header">General Message Header Fields</A></H3>

   There are a few header fields which have general applicability for both request and response 
   messages, but which do not apply to the communicating parties or the content being 
   transferred. These headers apply only to the message being transmitted.
<P>

<PRE>
       General-Header = Date                     ; <A HREF="#Date">Section 8.6</A>
                      | MIME-Version             ; <A HREF="#MIME-Version">Section 8.12</A>
                      | Pragma                   ; <A HREF="#Pragma">Section 8.13</A>
</PRE>

   General header field names can be extended only via a change in the protocol version. 
   Unknown header fields are treated as <CODE>Entity-Header</CODE> fields.
<P>

<H2>5. <A NAME="Request">Request</A></H2>

   A request message from a client to a server includes, within the first line of that message, the 
   method to be applied to the resource requested, the identifier of the resource, and the protocol 
   version in use. For backwards compatibility with the more limited HTTP/0.9 protocol, there 
   are two valid formats for an HTTP request:
<P>

<PRE>
       Request        = Simple-Request | Full-Request
</PRE>

<PRE>
       Simple-Request = "GET" SP Request-URI CRLF
</PRE>

<PRE>
       Full-Request   = Request-Line              ; <A HREF="#Request-Line">Section 5.1</A>
                        *( General-Header         ; <A HREF="#General-Header">Section 4.3</A>
                        |  Request-Header         ; <A HREF="#Request-Header">Section 5.4</A>
                        |  Entity-Header )        ; <A HREF="#Entity-Header">Section 7.1</A>
                        CRLF
                        [ Entity-Body ]           ; <A HREF="#Entity-Body">Section 7.2</A>
</PRE>

   If an HTTP/1.0 server receives a <CODE>Simple-Request</CODE>, it must respond with an HTTP/0.9
<CODE>Simple-Response</CODE>. An HTTP/1.0 client capable of receiving a <CODE>Full-Response</CODE> should never generate a 
   <CODE>Simple-Request</CODE>.
<P>

<H3>5.1  <A NAME="Request-Line">Request-Line</A></H3>

   The <CODE>Request-Line</CODE> begins with a method token, followed by the <CODE>Request-URI</CODE> and the protocol 
   version, and ending with <CODE>CRLF</CODE>. The elements are separated by <CODE>SP</CODE> characters. No <CODE>CR</CODE> or <CODE>LF</CODE> are 
   allowed except in the final <CODE>CRLF</CODE> sequence.
<P>

<PRE>
       Request-Line   = Method SP Request-URI SP HTTP-Version CRLF
</PRE>

   Note that the difference between a <CODE>Simple-Request</CODE> and the <CODE>Request-Line</CODE> of a <CODE>Full-Request</CODE> is the 
   presence of the <CODE>HTTP-Version</CODE> field and the availability of methods other than <CODE>GET</CODE>.
<P>

<H3>5.2  <A NAME="Method">Method</A></H3>

   The <CODE>Method</CODE> token indicates the method to be performed on the resource identified by the 
   <CODE>Request-URI</CODE>. The method is case-sensitive.
<P>

<PRE>
       Method         = "GET" | "HEAD" | "POST"
                      | extension-method
</PRE>

<PRE>
       extension-method = token
</PRE>

   The list of methods acceptable by a specific resource can change dynamically; the client is 
   notified through the return code of the response if a method is not allowed on a resource. 
   Servers should return the status code 501 (not implemented) if the method is unknown or not 
   implemented.
<P>

   The set of common methods for HTTP/1.0 is described below. Although this set can be easily 
   expanded, additional methods cannot be assumed to share the same semantics for separately 
   extended clients and servers.
<P>

<H4>5.2.1 <A NAME="GET">GET</A></H4>

   The <CODE>GET</CODE> method means retrieve whatever information (in the form of an entity) is identified by 
   the <CODE>Request-URI</CODE>. If the <CODE>Request-URI</CODE> refers to a data-producing process, it is the produced data 
   which shall be returned as the entity in the response and not the source text of the process, 
   unless that text happens to be the output of the process.
<P>

   The semantics of the <CODE>GET</CODE> method changes to a "conditional <CODE>GET</CODE>" if the request message 
   includes an <CODE>If-Modified-Since</CODE> header field. A conditional <CODE>GET</CODE> method requests that the identified 
   resource be transferred only if it has been modified since the date given by the <CODE>If-Modified-Since</CODE> 
   header, as described in <A HREF="#If-Modified-Since">Section 8.9</A>. The conditional <CODE>GET</CODE> method is intended to reduce network 
   usage by allowing cached entities to be refreshed without requiring multiple requests or 
   transferring unnecessary data.
<P>

<H4>5.2.2 <A NAME="HEAD">HEAD</A></H4>

   The <CODE>HEAD</CODE> method is identical to <CODE>GET</CODE> except that the server must not return any <CODE>Entity-Body</CODE> in 
   the response. The metainformation contained in the HTTP headers in response to a <CODE>HEAD</CODE> 
   request should be identical to the information sent in response to a <CODE>GET</CODE> request. This method 
   can be used for obtaining metainformation about the resource identified by the <CODE>Request-URI</CODE> 
   without transferring the <CODE>Entity-Body</CODE> itself. This method is often used for testing hypertext links 
   for validity, accessibility, and recent modification.
<P>

   There is no "conditional <CODE>HEAD</CODE>" request analogous to the conditional <CODE>GET</CODE>. If an <CODE>If-Modified-Since</CODE> 
   header field is included with a <CODE>HEAD</CODE> request, it should be ignored.
<P>

<H4>5.2.3 <A NAME="POST">POST</A></H4>

   The <CODE>POST</CODE> method is used to request that the destination server accept the entity enclosed in the 
   request as a new subordinate of the resource identified by the <CODE>Request-URI</CODE> in the <CODE>Request-Line</CODE>. 
   <CODE>POST</CODE> is designed to allow a uniform method to cover the following functions:
<P>

<UL>
<LI>       Annotation of existing resources; 
<LI>       Posting a message to a bulletin board, newsgroup, mailing list, or similar group of 
        articles;
<LI>       Providing a block of data, such as the result of submitting a form<A HREF="#46155"> [3]</A>, to a data-handling 
        process;
<LI>       Extending a database through an append operation.
</UL>
   The actual function performed by the <CODE>POST</CODE> method is determined by the server and is usually 
   dependent on the <CODE>Request-URI</CODE>. The posted entity is subordinate to that URI in the same way 
   that a file is subordinate to a directory containing it, a news article is subordinate to a 
   newsgroup to which it is posted, or a record is subordinate to a database.
<P>

   A successful <CODE>POST</CODE> does not require that the entity be created as a resource on the origin server 
   or made accessible for future reference. That is, the action performed by the <CODE>POST</CODE> method 
   might not result in a resource that can be identified by a URI. In this case, either 200 (ok) or 
   204 (no content) is the appropriate response status, depending on whether or not the response 
   includes an entity that describes the result.
<P>

   If a resource has been created on the origin server, the response should be 201 (created) and 
   contain an entity (preferably of type "text/html") which describes the status of the request and 
   refers to the new resource.
<P>

   A valid <CODE>Content-Length</CODE> is required on all HTTP/1.0 <CODE>POST</CODE> requests. An HTTP/1.0 server should 
   respond with a 400 (bad request) message if it cannot determine the length of the request 
   message's content.
<P>

   Caching intermediaries must not cache responses to a <CODE>POST</CODE> request.
<P>

<H3>5.3  <A NAME="Request-URI">Request-URI</A></H3>

   The <CODE>Request-URI</CODE> is a Uniform Resource Identifier (<A HREF="#URI">Section 3.2</A>) and identifies the resource upon 
   which to apply the request.
<P>

<PRE>
       Request-URI    = absoluteURI | abs_path
</PRE>

   The two options for <CODE>Request-URI</CODE> are dependent on the nature of the request.
<P>

   The <CODE>absoluteURI</CODE> form is only allowed when the request is being made to a proxy server. The 
   proxy is requested to forward the request and return the response. If the request is <CODE>GET</CODE> or <CODE>HEAD</CODE> 
   and a response is cached, the proxy may use the cached message if it passes any restrictions in 
   the <CODE>Expires</CODE> header field. Note that the proxy may forward the request on to another proxy or 
   directly to the origin server specified by the <CODE>absoluteURI</CODE>. In order to avoid request loops, a 
   proxy must be able to recognize all of its server names, including any aliases, local variations, 
   and the numeric IP address. An example Request-Line would be:
<P>

<PRE>
       GET http://www.w3.org/hypertext/WWW/TheProject.html HTTP/1.0
</PRE>

   The most common form of <CODE>Request-URI</CODE> is that used to identify a resource on an origin server. 
   In this case, only the absolute path of the URI is transmitted (see <A HREF="#URI-syntax">Section 3.2.1</A>, <CODE>abs_path</CODE>). For 
   example, a client wishing to retrieve the resource above directly from the origin server would 
   create a TCP connection to port 80 of the host "www.w3.org" and send the line:
<P>

<PRE>
       GET /hypertext/WWW/TheProject.html HTTP/1.0
</PRE>

   followed by the remainder of the Full-Request. Note that the absolute path cannot be empty; if 
   none is present in the original URI, it must be given as "/" (the server root).
<P>

<H3>5.4  <A NAME="Request-Header">Request Header Fields</A></H3>

   The request header fields allow the client to pass additional information about the request, and 
   about the client itself, to the server. All header fields are optional and conform to the generic 
   <CODE>HTTP-header</CODE> syntax.
<P>

<PRE>
       Request-Header = Authorization            ; <A HREF="#Authorization">Section 8.2</A>
                      | From                     ; <A HREF="#From">Section 8.8</A>
                      | If-Modified-Since        ; <A HREF="#If-Modified-Since">Section 8.9</A>
                      | Referer                  ; <A HREF="#Referer">Section 8.14</A>
                      | User-Agent               ; <A HREF="#User-Agent">Section 8.16</A>
</PRE>

   <CODE>Request-Header</CODE> field names can be extended only via a change in the protocol version. 
   Unknown header fields are treated as <CODE>Entity-Header</CODE> fields.
<P>

<H2>6.  <A NAME="Response">Response</A></H2>

   After receiving and interpreting a request message, a server responds in the form of an HTTP 
   response message.
<P>

<PRE>
       Response        = Simple-Response | Full-Response
</PRE>

<PRE>
       Simple-Response = [ Entity-Body ]
</PRE>

<PRE>
       Full-Response   = Status-Line               ; <A HREF="#Status-Line">Section 6.1</A>
                         *( General-Header         ; <A HREF="#General-Header">Section 4.3</A>
                         |  Response-Header        ; <A HREF="#Response-Header">Section 6.3</A>
                         |  Entity-Header )        ; <A HREF="#Entity-Header">Section 7.1</A>
                         CRLF
                         [ Entity-Body ]           ; <A HREF="#Entity-Body">Section 7.2</A>
</PRE>

   A <CODE>Simple-Response</CODE> should only be sent in response to an HTTP/0.9 <CODE>Simple-Request</CODE> or if the 
   server only supports the more limited HTTP/0.9 protocol. If a client sends an HTTP/1.0
<CODE>Full-Request</CODE> and receives a response that does not begin with a <CODE>Status-Line</CODE>, it should assume that the 
   response is a <CODE>Simple-Response</CODE> and parse it accordingly. Note that the <CODE>Simple-Response</CODE> consists 
   only of the entity body and is terminated by the server closing the connection.
<P>

<H3>6.1  <A NAME="Status-Line">Status-Line</A></H3>

   The first line of a <CODE>Full-Response</CODE> message is the <CODE>Status-Line</CODE>, consisting of the protocol version 
   followed by a numeric status code and its associated textual phrase, with each element 
   separated by <CODE>SP</CODE> characters. No <CODE>CR</CODE> or <CODE>LF</CODE> is allowed except in the final <CODE>CRLF</CODE> sequence.
<P>

<PRE>
       Status-Line    = HTTP-Version SP Status-Code SP Reason-Phrase CRLF
</PRE>

   Since a status line always begins with the protocol version and status code
<P>

<PRE>
       "HTTP/" 1*DIGIT "." 1*DIGIT SP 3DIGIT SP
</PRE>

   (e.g., <CODE>"HTTP/1.0 200 "</CODE>), the presence of that expression is sufficient to differentiate a
<CODE>Full-Response</CODE> from a <CODE>Simple-Response</CODE>. Although the <CODE>Simple-Response</CODE> format may allow such an 
   expression to occur at the beginning of an entity body, and thus cause a misinterpretation of the 
   message if it was given in response to a <CODE>Full-Request</CODE>, most HTTP/0.9 servers are limited to 
   responses of type "text/html" and therefore would never generate such a response.
<P>

<H3>6.2  <A NAME="Status-Codes">Status Codes and Reason Phrases</A></H3>

   The <CODE>Status-Code</CODE> element is a 3-digit integer result code of the attempt to understand and satisfy 
   the request. The <CODE>Reason-Phrase</CODE> is intended to give a short textual description of the <CODE>Status-Code</CODE>. 
   The <CODE>Status-Code </CODE>is intended for use by automata and the <CODE>Reason-Phrase</CODE> is intended for the 
   human user. The client is not required to examine or display the <CODE>Reason-Phrase</CODE>.
<P>

   The first digit of the <CODE>Status-Code</CODE> defines the class of response. The last two digits do not have 
   any categorization role. There are 5 values for the first digit:
<P>

<UL>
<LI>       1xx: Informational - Not used, but reserved for future use
<LI>       2xx: Success - The action was successfully received, understood, and accepted.
<LI>       3xx: Redirection - Further action must be taken in order to complete the request
<LI>       4xx: Client Error - The request contains bad syntax or cannot be fulfilled
<LI>       5xx: Server Error - The server failed to fulfill an apparently valid request
</UL>
   The individual values of the numeric status codes defined for HTTP/1.0, and an example set of 
   corresponding <CODE>Reason-Phrase</CODE>'s, are presented below. The reason phrases listed here are only 
   recommended -- they may be replaced by local equivalents without affecting the protocol. 
<P>

<PRE>
       Status-Code    = "200"   ; OK
                      | "201"   ; Created
                      | "202"   ; Accepted
                      | "204"   ; No Content
                      | "301"   ; Moved Permanently
                      | "302"   ; Moved Temporarily
                      | "304"   ; Not Modified
                      | "400"   ; Bad Request
                      | "401"   ; Unauthorized
                      | "403"   ; Forbidden
                      | "404"   ; Not Found
                      | "500"   ; Internal Server Error
                      | "501"   ; Not Implemented
                      | "502"   ; Bad Gateway
                      | "503"   ; Service Unavailable
                      | extension-code
</PRE>

<PRE>
       extension-code = 3DIGIT
</PRE>

<PRE>
       Reason-Phrase  = *&lt;text, excluding CR, LF&gt;
</PRE>

   HTTP status codes are extensible, but the above codes are the only ones generally recognized 
   in current practice. HTTP applications are not required to understand the meaning of all 
   registered status codes, though such understanding is obviously desirable. However, 
   applications must understand the class of any status code, as indicated by the first digit, and 
   treat any unknown response as being equivalent to the x00 status code of that class. For 
   example, if an unknown status code of 421 is received by the client, it can safely assume that 
   there was something wrong with its request and treat the response as if it had received a 400 
   status code. In such cases, user agents are encouraged to present the entity returned with the 
   response to the user, since that entity is likely to include human-readable information which 
   will explain the unusual status.
<P>

   Each <CODE>Status-Code</CODE> is described below, including a description of which <CODE>method</CODE>(s) it can follow 
   and any metainformation required in the response.
<P>

<H4>6.2.1 <A NAME="Code1xx">Informational 1xx</A></H4>

   This class of status code indicates a provisional response, consisting only of the Status-Line 
   and optional headers, and is terminated by an empty line. HTTP/1.0 does not define any 1xx 
   status codes and they are not a valid response to a HTTP/1.0 request. However, they may be 
   useful for experimental applications which are outside the scope of this specification.
<P>

<H4>6.2.2 <A NAME="Code2xx">Successful 2xx</A></H4>

   This class of status code indicates that the client's request was successfully received, 
   understood, and accepted.
<P>

<H5>   <A NAME="Code200">200 OK</A></H5>

   The request has succeeded. The information returned with the response is dependent on the 
   method used in the request, as follows:
<P>

<DL COMPACT>
<DT><CODE>GET</CODE>
<DD>an entity corresponding to the requested resource is being sent in the response;
</DL>

<DL COMPACT>
<DT><CODE>HEAD</CODE>
<DD>the response must only contain the header information and no <CODE>Entity-Body</CODE>;
</DL>

<DL COMPACT>
<DT><CODE>POST</CODE>
<DD>an entity describing or containing the result of the action.
</DL>

<H5>   <A NAME="Code201">201 Created</A></H5>

   The request has been fulfilled and resulted in a new resource being created. The newly created 
   resource can be referenced by the URI(s) returned in the entity of the response. The origin 
   server is encouraged, but not obliged, to actually create the resource before using this
<CODE>Status-Code</CODE>. If the action cannot be carried out immediately, or within a clearly defined timeframe, the 
   server should respond with 202 (accepted) instead.
<P>

   Of the methods defined by this specification, only <CODE>POST</CODE> can create a resource.
<P>

<H5>   <A NAME="Code202">202 Accepted</A></H5>

   The request has been accepted for processing, but the processing has not been completed. The 
   request may or may not eventually be acted upon, as it may be disallowed when processing 
   actually takes place. There is no facility for re-sending a status code from an asynchronous 
   operation such as this.
<P>

   The 202 response is intentionally non-committal. Its purpose is to allow a server to accept a 
   request for some other process (perhaps a batch-oriented process that is only run once per day) 
   without requiring that the user agent's connection to the server persist until the process is 
   completed. The entity returned with this response should include an indication of the request's 
   current status and either a pointer to a status monitor or some estimate of when the user can 
   expect the request to be fulfilled.
<P>

<H5>   <A NAME="Code204">204 No Content</A></H5>

   The server has fulfilled the request but there is no new information to send back. If the client is 
   a user agent, it should not change its document view from that which caused the request to be 
   generated. This response is primarily intended to allow input for scripts or other actions to take 
   place without causing a change to the user agent's active document view. The response may 
   include new metainformation in the form of entity headers, which should apply to the 
   document currently in the user agent's active view.
<P>

<H4>6.2.3 <A NAME="Code3xx">Redirection 3xx</A></H4>

   This class of status code indicates that further action needs to be taken by the user agent in order 
   to fulfill the request. The action required can sometimes be carried out by the user agent without 
   interaction with the user, but it is strongly recommended that this only take place if the method 
   used in the request is <CODE>GET</CODE> or <CODE>HEAD</CODE>. A user agent should never automatically redirect a request 
   more than 5 times, since such redirections usually indicate an infinite loop.
<P>

<H5>   <A NAME="Code300">300 Multiple Choices</A></H5>

   This response code is not directly used by HTTP/1.0 applications, but serves as the default for 
   interpreting the 3xx class of responses.
<P>

   The requested resource is available at one or more locations. Unless it was a <CODE>HEAD</CODE> request, the 
   response should include an entity containing a list of resource characteristics and locations 
   from which the user or user agent can choose the one most appropriate. If the server has a 
   preferred choice, it should include the URL in a <CODE>Location</CODE> field; user agents may use the <CODE>Location</CODE> 
   value for automatic redirection.
<P>

<H5>   <A NAME="Code301">301 Moved Permanently</A></H5>

   The requested resource has been assigned a new permanent URL and any future references to 
   this resource should be done using that URL. Clients with link editing capabilities are 
   encouraged to automatically relink references to the <CODE>Request-URI</CODE> to the new reference returned 
   by the server, where possible.
<P>

   The new URL must be given by the <CODE>Location</CODE> field in the response. Unless it was a <CODE>HEAD</CODE> request, 
   the <CODE>Entity-Body</CODE> of the response should contain a short note with a hyperlink to the new URL.
<P>

   If the 301 status code is received in response to a request using the <CODE>POST</CODE> method, the user agent 
   must not automatically redirect the request unless it can be confirmed by the user, since this 
   might change the conditions under which the request was issued.
<P>

<H5>   <A NAME="Code302">302 Moved Temporarily</A></H5>

   The requested resource resides temporarily under a different URL. Since the redirection may 
   be altered on occasion, the client should continue to use the <CODE>Request-URI</CODE> for future requests.
<P>

   The URL must be given by the <CODE>Location</CODE> field in the response. Unless it was a <CODE>HEAD</CODE> request, the 
   <CODE>Entity-Body</CODE> of the response should contain a short note with a hyperlink to the new URI(s).
<P>

   If the 302 status code is received in response to a request using the <CODE>POST</CODE> method, the user agent 
   must not automatically redirect the request unless it can be confirmed by the user, since this 
   might change the conditions under which the request was issued.
<P>

<H5>   <A NAME="Code304">304 Not Modified</A></H5>

   If the client has performed a conditional <CODE>GET</CODE> request and access is allowed, but the document 
   has not been modified since the date and time specified in the <CODE>If-Modified-Since</CODE> field, the server 
   shall respond with this status code and not send an <CODE>Entity-Body</CODE> to the client. Header fields 
   contained in the response should only include information which is relevant to cache managers 
   and which may have changed independently of the entity's <CODE>Last-Modified</CODE> date. Examples of 
   relevant header fields include: <CODE>Date</CODE>, <CODE>Server</CODE>, and <CODE>Expires</CODE>.
<P>

<H4>6.2.4 <A NAME="Code4xx">Client Error 4xx</A></H4>

   The 4xx class of status code is intended for cases in which the client seems to have erred. If the 
   client has not completed the request when a 4xx code is received, it should immediately cease 
   sending data to the server. Except when responding to a <CODE>HEAD</CODE> request, the server is encouraged 
   to include an entity containing an explanation of the error situation, and whether it is a 
   temporary or permanent condition. These status codes are applicable to any request method.
<P>

<BLOCKQUOTE>
       Note: If the client is sending data, server implementations on TCP should be careful 
       to ensure that the client acknowledges receipt of the packet(s) containing the response 
       prior to closing the input connection. If the client continues sending data to the server 
       after the close, the server's controller will send a reset packet to the client, which may 
       erase the client's unacknowledged input buffers before they can be read and 
       interpreted by the HTTP application.
</BLOCKQUOTE>

<H5>   <A NAME="Code400">400 Bad Request</A></H5>

   The request could not be understood by the server due to malformed syntax. The client is 
   discouraged from repeating the request without modifications.
<P>

<H5>   <A NAME="Code401">401 Unauthorized</A></H5>

   The request requires user authentication. The response must include a <CODE>WWW-Authenticate</CODE> 
   header field (<A HREF="#WWW-Authenticate">Section 8.17</A>) containing a <CODE>challenge</CODE> applicable to the requested resource. The 
   client may repeat the request with a suitable <CODE>Authorization</CODE> header field. If the request already 
   included Authorization credentials, then the 401 response indicates that authorization has been 
   refused for those credentials. If the 401 response contains the same challenge as the prior 
   response, and the user agent has already attempted authentication at least once, then the user 
   should be presented the entity that was given in the response, since that entity may include 
   relevent diagnostic information. HTTP access authentication is explained in <A HREF="#AA">Section 9</A>.
<P>

<H5>   <A NAME="Code403">403 Forbidden</A></H5>

   The server understood the request, but is refusing to perform the request for an unspecified 
   reason. Authorization will not help and the request should not be repeated. This status code can 
   be used if the server does not want to make public why the request has not been fulfilled.
<P>

<H5>   <A NAME="Code404">404 Not Found</A></H5>

   The server has not found anything matching the <CODE>Request-URI</CODE>. No indication is given of whether 
   the condition is temporary or permanent. If the server does not wish to make this information 
   available to the client, the status code 403 (forbidden) can be used instead.
<P>

<H4>6.2.5 <A NAME="Code5xx">Server Errors 5xx</A></H4>

   Response status codes beginning with the digit "5" indicate cases in which the server is aware 
   that it has erred or is incapable of performing the request. If the client has not completed the 
   request when a 5xx code is received, it should immediately cease sending data to the server. 
   Except when responding to a <CODE>HEAD</CODE> request, the server is encouraged to include an entity 
   containing an explanation of the error situation, and whether it is a temporary or permanent 
   condition. These response codes are applicable to any request method and there are no required 
   header fields.
<P>

<H5>   <A NAME="Code500">500 Internal Server Error</A></H5>

   The server encountered an unexpected condition which prevented it from fulfilling the request. 
<P>

<H5>   <A NAME="Code501">501 Not Implemented</A></H5>

   The server does not support the functionality required to fulfill the request. This is the 
   appropriate response when the server does not recognize the request method and is not capable 
   of supporting it for any resource.
<P>

<H5>   <A NAME="Code502">502 Bad Gateway</A></H5>

   The server received an invalid response from the gateway or upstream server it accessed in 
   attempting to fulfill the request.
<P>

<H5>   <A NAME="Code503">503 Service Unavailable</A></H5>

   The server is currently unable to handle the request due to a temporary overloading or 
   maintenance of the server. The implication is that this is a temporary condition which will be 
   alleviated after some delay.
<P>

<BLOCKQUOTE>
       Note: The existence of the 503 status code does not imply that a server must use it 
       when becoming overloaded. Some servers may wish to simply refuse the connection.
</BLOCKQUOTE>

<H3>6.3  <A NAME="Response-Header">Response Header Fields</A></H3>

   The response header fields allow the server to pass additional information about the response 
   which cannot be placed in the <CODE>Status-Line</CODE>. These header fields are not intended to give 
   information about an <CODE>Entity-Body</CODE> returned in the response, but about the server itself.
<P>

<PRE>
       Response-Header = Location                ; <A HREF="#Location">Section 8.11</A>
                       | Server                  ; <A HREF="#Server">Section 8.15</A>
                       | WWW-Authenticate        ; <A HREF="#WWW-Authenticate">Section 8.17</A>
</PRE>

   <CODE>Response-Header</CODE> field names can be extended only via a change in the protocol version. 
   Unknown header fields are treated as <CODE>Entity-Header</CODE> fields.
<P>

<H2>7.  <A NAME="Entity">Entity</A></H2>

   <CODE>Full-Request</CODE> and <CODE>Full-Response</CODE> messages may transfer an entity within some requests and 
   responses. An entity consists of <CODE>Entity-Header</CODE> fields and (usually) an <CODE>Entity-Body</CODE>. In this section, 
   both <EM>sender </EM>and<EM> recipient</EM> refer to either the client or the server, depending on who sends and 
   who receives the entity.
<P>

<H3>7.1  <A NAME="Entity-Header">Entity Header Fields</A></H3>

   <CODE>Entity-Header</CODE> fields define optional metainformation about the <CODE>Entity-Body</CODE> or, if no body is 
   present, about the resource identified by the request.
<P>

<PRE>
       Entity-Header  = Allow                    ; <A HREF="#Allow">Section 8.1</A>
                      | Content-Encoding         ; <A HREF="#Content-Encoding">Section 8.3</A>
                      | Content-Length           ; <A HREF="#Content-Length">Section 8.4</A>
                      | Content-Type             ; <A HREF="#Content-Type">Section 8.5</A>
                      | Expires                  ; <A HREF="#Expires">Section 8.7</A>
                      | Last-Modified            ; <A HREF="#Last-Modified">Section 8.10</A>
                      | extension-header
</PRE>

<PRE>
       extension-header = HTTP-header
</PRE>

   The <CODE>extension-header</CODE> mechanism allows additional <CODE>Entity-Header</CODE> to be defined without changing 
   the protocol, but these fields cannot be assumed to be recognizable by the recipient. Unknown 
   header fields should be ignored by the recipient and forwarded by proxies.
<P>

<H3>7.2  <A NAME="Entity-Body">Entity Body</A></H3>

   The entity-body (if any) sent with an HTTP/1.0 request or response is in a format and encoding 
   defined by the <CODE>Entity-Header</CODE> fields.
<P>

<PRE>
       Entity-Body    = *OCTET
</PRE>

   An entity-body is included with a request message only when the request method calls for one. 
   This specification defines one request method, <CODE>POST</CODE>, that allows an entity-body. In general, the 
   presence of an entity-body in a request is signaled by the inclusion of a <CODE>Content-Length</CODE> header 
   field in the request message headers. HTTP/1.0 requests containing content must include a 
   valid <CODE>Content-Length</CODE> header field.
<P>

   For response messages, whether or not an entity-body is included with a message is dependent 
   on both the request method and the response code. All responses to the <CODE>HEAD</CODE> request method 
   must not include a body, even though the presence of content header fields may lead one to 
   believe they do. The responses 204 (no content) and 304 (not modified) must not include a 
   message body.
<P>

<H4>7.2.1 <A NAME="BodyType">Type</A></H4>

   When an <CODE>Entity-Body</CODE> is included with a message, the data type of that body is determined via 
   the header fields <CODE>Content-Type</CODE> and <CODE>Content-Encoding</CODE>. These define a two-layer, ordered 
   encoding model:
<P>

<PRE>
       entity-body := Content-Encoding( Content-Type( data ) )
</PRE>

   A <CODE>Content-Type</CODE> specifies the media type of the underlying data. A <CODE>Content-Encoding</CODE> may be used 
   to indicate any additional content coding applied to the type, usually for the purpose of data 
   compression, that is a property of the resource requested. The default for the content encoding 
   is none (i.e., the identity function).
<P>

   The <CODE>Content-Type</CODE> header field has no default value. If and <STRONG>only if</STRONG> the media type is not given 
   by a <CODE>Content-Type</CODE> header, as is always the case for <CODE>Simple-Response</CODE> messages, the receiver may 
   attempt to guess the media type via inspection of its content and/or the name extension(s) of 
   the URL used to specify the resource. If the media type remains unknown, the receiver should 
   treat it as type "<CODE>application/octet-stream</CODE>".
<P>

<H4>7.2.2 <A NAME="BodyLength">Length</A></H4>

   When an <CODE>Entity-Body</CODE> is included with a message, the length of that body may be determined in 
   one of several ways. If a <CODE>Content-Length</CODE> header field is present, its value in bytes represents the 
   length of the <CODE>Entity-Body</CODE>. Otherwise, the body length is determined by the closing of the 
   connection by the server.
<P>

   Closing the connection cannot be used to indicate the end of a request body, since it leaves no 
   possibility for the server to send back a response. Therefore, HTTP/1.0 requests containing 
   content must include a valid <CODE>Content-Length</CODE> header field. If a request contains an entity body 
   and <CODE>Content-Length</CODE> is not specified, and the server does not recognize or cannot calculate the 
   length from other fields, then the server should send a 400 (bad request) response.
<P>

<BLOCKQUOTE>
       Note: Some older servers supply an invalid Content-Length when sending a 
       document that contains server-side includes dynamically inserted into the data 
       stream. It must be emphasized that this will not be tolerated by future versions of 
       HTTP. Unless the client knows that it is receiving a response from a compliant server, 
       it should not depend on the Content-Length value being correct.
</BLOCKQUOTE>

<H2>8.  <A NAME="HeaderFields">Header Field Definitions</A></H2>

   This section defines the syntax and semantics of all standard HTTP/1.0 header fields. For
<CODE>Entity-Header</CODE> fields, both <EM>sender </EM>and<EM> recipient</EM> refer to either the client or the server, depending on 
   who sends and who receives the entity.
<P>

<H3>8.1  <A NAME="Allow">Allow</A></H3>

   The <CODE>Allow</CODE> header field lists the set of methods supported by the resource identified by the 
   <CODE>Request-URI</CODE>. The purpose of this field is strictly to inform the recipient of valid methods 
   associated with the resource. The <CODE>Allow</CODE> header field is not permitted in a request using the <CODE>POST</CODE> 
   method, and thus should be ignored if it is received as part of a <CODE>POST</CODE> entity.
<P>

<PRE>
       Allow          = "Allow" ":" 1#method
</PRE>

    Example of use:
<P>

<PRE>
       Allow: GET, HEAD
</PRE>

   This field cannot prevent a client from trying other methods. However, the indications given by 
   the <CODE>Allow</CODE> field value should be followed. This field has no default value; if left undefined, the 
   set of allowed methods is defined by the origin server at the time of each request.
<P>

   A proxy must not modify the allow header even if it does not understand all the methods 
   specified, since the user agent may have other means of communicating with the origin server.
<P>

   The <CODE>Allow</CODE> header field does not indicate what methods are implemented by the server.
<P>

<H3>8.2  <A NAME="Authorization">Authorization</A></H3>

   A user agent that wishes to authenticate itself with a server--usually, but not necessarily, after 
   receiving a 401 response--may do so by including an <CODE>Authorization</CODE> header field with the 
   request. The <CODE>Authorization</CODE> field value consists of <CODE>credentials</CODE> containing the authentication 
   information of the user agent for the realm of the resource being requested.
<P>

<PRE>
       Authorization  = "Authorization" ":" credentials
</PRE>

   HTTP access authentication is described in <A HREF="#AA">Section 9</A>. If a request is authenticated and a <CODE>realm</CODE> 
   specified, the same <CODE>credentials</CODE> should be valid for all other requests within this <CODE>realm</CODE>.
<P>

   Proxies must not cache the response to a request containing an <CODE>Authorization</CODE> field.
<P>

<H3>8.3  <A NAME="Content-Encoding">Content-Encoding</A></H3>

   The <CODE>Content-Encoding</CODE> header field is used as a modifier to the <CODE>media-type</CODE>. When present, its 
   value indicates what additional content coding has been applied to the resource, and thus what 
   decoding mechanism must be applied in order to obtain the <CODE>media-type</CODE> referenced by the 
   <CODE>Content-Type</CODE> header field. The <CODE>Content-Encoding</CODE> is primarily used to allow a document to be 
   compressed without losing the identity of its underlying media type.
<P>

<PRE>
       Content-Encoding = "Content-Encoding" ":" content-coding
</PRE>

   Content codings are defined in <A HREF="#Content-Codings">Section 3.5</A>. An example of its use is
<P>

<PRE>
       Content-Encoding: x-gzip
</PRE>

   The Content-Encoding is a characteristic of the resource identified by the <CODE>Request-URI</CODE>. 
   Typically, the resource is stored with this encoding and is only decoded before rendering or 
   analogous usage.
<P>

<H3>8.4  <A NAME="Content-Length">Content-Length</A></H3>

   The <CODE>Content-Length</CODE> header field indicates the size of the <CODE>Entity-Body</CODE>, in decimal number of 
   octets, sent to the recipient or, in the case of the <CODE>HEAD</CODE> method, the size of the <CODE>Entity-Body</CODE> that 
   would have been sent had the request been a <CODE>GET</CODE>.
<P>

<PRE>
       Content-Length = "Content-Length" ":" 1*DIGIT
</PRE>

   An example is
<P>

<PRE>
       Content-Length: 3495
</PRE>

   Although it is not required, applications are strongly encouraged to use this field to indicate the 
   size of the <CODE>Entity-Body</CODE> to be transferred, regardless of the media type of the entity.
<P>

   Any <CODE>Content-Length</CODE> greater than or equal to zero is a valid value. <A HREF="#BodyLength">Section 7.2.2</A> describes how 
   to determine the length of an <CODE>Entity-Body</CODE> if a <CODE>Content-Length</CODE> is not given.
<P>

<BLOCKQUOTE>
       Note: The meaning of this field is significantly different from the corresponding 
       definition in MIME, where it is an optional field used within the "message/external-body"
       content-type. In HTTP, it should be used whenever the entity's length can be 
       determined prior to being transferred.
</BLOCKQUOTE>

<H3>8.5  <A NAME="Content-Type">Content-Type</A></H3>

   The <CODE>Content-Type</CODE> header field indicates the media type of the <CODE>Entity-Body</CODE> sent to the recipient 
   or, in the case of the <CODE>HEAD</CODE> method, the media type that would have been sent had the request 
   been a <CODE>GET</CODE>.
<P>

<PRE>
       Content-Type   = "Content-Type" ":" media-type
</PRE>

   Media types are defined in <A HREF="#Media-Types">Section 3.6</A>. An example of the field is
<P>

<PRE>
       Content-Type: text/html
</PRE>

   The <CODE>Content-Type</CODE> header field has no default value. Further discussion of methods for 
   identifying the media type of an entity is provided in <A HREF="#BodyType">Section 7.2.1</A>.
<P>

<H3>8.6  <A NAME="Date">Date</A></H3>

   The <CODE>Date</CODE> header represents the date and time at which the message was originated, having the 
   same semantics as <CODE>orig-date</CODE> in RFC 822. The field value is an <CODE>HTTP-date</CODE>, as described in 
   <A HREF="#DateFormats">Section 3.3</A>.
<P>

<PRE>
       Date           = "Date" ":" HTTP-date
</PRE>

   An example is
<P>

<PRE>
       Date: Tue, 15 Nov 1994 08:12:31 GMT
</PRE>

   If a message is received via direct connection with the user agent (in the case of requests) or 
   the origin server (in the case of responses), then the default date can be assumed to be the 
   current date at the receiving end. However, since the date--as it is believed by the origin--is 
   important for evaluating cached responses, origin servers should always include a <CODE>Date</CODE> header. 
   Clients should only send a <CODE>Date</CODE> header field in messages that include an entity body, as in the 
   case of the <CODE>POST</CODE> request, and even then it is optional. A received message which does not have 
   a <CODE>Date</CODE> header field should be assigned one by the receiver if and only if the message will be 
   cached by that receiver or gatewayed via a protocol which requires a <CODE>Date</CODE>.
<P>

   Only one <CODE>Date</CODE> header field is allowed per message. In theory, the date should represent the 
   moment just before the entity is generated. In practice, the date can be generated at any time 
   during the message origination without affecting its semantic value.
<P>

<BLOCKQUOTE>
       Note:  An earlier version of this document incorrectly specified that this field should 
       contain the creation date of the enclosed <CODE>Entity-Body</CODE>. This has been changed to reflect 
       actual (and proper) usage.
</BLOCKQUOTE>

<H3>8.7  <A NAME="Expires">Expires</A></H3>

   The <CODE>Expires</CODE> field gives the date/time after which the entity should be considered stale. This 
   allows information providers to suggest the volatility of the resource. Caching clients, 
   including proxies, must not cache this copy of the resource beyond the date given, unless its 
   status has been updated by a later check of the origin server. The presence of an Expires field 
   does not imply that the original resource will change or cease to exist at, before, or after that 
   time. However, information providers that know or even suspect that a resource will change by 
   a certain date are strongly encouraged to include an Expires header with that date. The format 
   is an absolute date and time as defined by <CODE>HTTP-date</CODE> in <A HREF="#DateFormats">Section 3.3</A>.
<P>

<PRE>
       Expires        = "Expires" ":" HTTP-date
</PRE>

   An example of its use is
<P>

<PRE>
       Expires: Thu, 01 Dec 1994 16:00:00 GMT
</PRE>

   The <CODE>Expires</CODE> field has no default value. If the date given is equal to or earlier than the value of 
   the <CODE>Date</CODE> header, the recipient must not cache the enclosed entity. If a resource is dynamic by 
   nature, as is the case with many data-producing processes, copies of that resource should be 
   given an appropriate Expires value which reflects that dynamism.
<P>

   The Expires field cannot be used to force a user agent to refresh its display or reload a resource; 
   its semantics apply only to caching mechanisms, and such mechanisms need only check a 
   resource's expiration status when a new request for that resource is initiated.
<P>

   User agents often have history mechanisms, such as "Back" buttons and history lists, which can 
   be used to redisplay an entity retrieved earlier in a session. By default, the <CODE>Expires</CODE> field does not 
   apply to history mechanisms. If the entity is still in storage, a history mechanism should display 
   it even if the entity has expired, unless the user has specifically configured the agent to refresh 
   expired history documents.
<P>

<BLOCKQUOTE>
       Note: Applications are encouraged to be tolerant of bad or misinformed 
       implementations of the Expires header. A value of zero (0) or an invalid date format 
       should be considered equivalent to an "expires immediately." Although these values 
       are not legitimate for HTTP/1.0, a robust implementation is always desirable.
</BLOCKQUOTE>

<H3>8.8  <A NAME="From">From</A></H3>

   The <CODE>From</CODE> header field, if given, should contain an Internet e-mail address for the human user 
   who controls the requesting user agent. The address should be machine-usable, as defined by 
   <CODE>mailbox</CODE> in RFC 822<A HREF="#96313"> [7]</A> (as updated by RFC 1123<A HREF="#40086"> [6]</A>):
<P>

<PRE>
       From           = "From" ":" mailbox
</PRE>

   An example is:
<P>

<PRE>
       From: webmaster@w3.org
</PRE>

   This header field may be used for logging purposes and as a means for identifying the source 
   of invalid or unwanted requests. It should not be used as an insecure form of access protection. 
   The interpretation of this field is that the request is being performed on behalf of the person 
   given, who accepts responsibility for the <CODE>method</CODE> performed. In particular, robot agents should 
   include this header so that the person responsible for running the robot can be contacted if 
   problems occur on the receiving end.
<P>

   The Internet e-mail address in this field may be separate from the Internet host which issued 
   the request. For example, when a request is passed through a proxy, the original issuer's address 
   should be used.
<P>

<BLOCKQUOTE>
       Note: The client should not send the <CODE>From</CODE> header field without the user's approval, as 
       it may conflict with the user's privacy interests or their site's security policy. It is 
       strongly recommended that the user be able to disable, enable, and modify the value 
       of this field at any time prior to a request.
</BLOCKQUOTE>

<H3>8.9  <A NAME="If-Modified-Since">If-Modified-Since</A></H3>

   The <CODE>If-Modified-Since</CODE> header field is used with the <CODE>GET</CODE> method to make it conditional: if the 
   requested resource has not been modified since the time specified in this field, a copy of the 
   resource will not be returned from the server; instead, a 304 (not modified) response will be 
   returned without any <CODE>Entity-Body</CODE>.
<P>

<PRE>
       If-Modified-Since = "If-Modified-Since" ":" HTTP-date
</PRE>

   An example of the field is:
<P>

<PRE>
       If-Modified-Since: Sat, 29 Oct 1994 19:43:31 GMT
</PRE>

   A conditional <CODE>GET</CODE> method requests that the identified resource be transferred only if it has been 
   modified since the date given by the <CODE>If-Modified-Since</CODE> header. The algorithm for determining this 
   includes the following cases:
<P>

<DL COMPACT>
<DT>a)
<DD>If the request would normally result in anything other than a 200 (ok) status, or if 
              the passed <CODE>If-Modified-Since</CODE> date is invalid, the response is exactly the same as for a 
              normal <CODE>GET</CODE>. A date which is later than the server's current time is invalid.
<DT>b)
<DD>If the resource has been modified since the <CODE>If-Modified-Since</CODE> date, the response is 
              exactly the same as for a normal <CODE>GET</CODE>.
<DT>c)
<DD>If the resource has not been modified since a valid <CODE>If-Modified-Since</CODE> date, the server 
              shall return a 304 (not modified) response.
</DL>

   The purpose of this feature is to allow efficient updates of cached information with a minimum 
   amount of transaction overhead.
<P>

<H3>8.10  <A NAME="Last-Modified">Last-Modified</A></H3>

   The <CODE>Last-Modified</CODE> header field indicates the date and time at which the sender believes the 
   resource was last modified. The exact semantics of this field are defined in terms of how the 
   receiver should interpret it:  if the receiver has a copy of this resource which is older than the 
   date given by the <CODE>Last-Modified</CODE> field, that copy should be considered stale.
<P>

<PRE>
       Last-Modified  = "Last-Modified" ":" HTTP-date
</PRE>

   An example of its use is
<P>

<PRE>
       Last-Modified: Tue, 15 Nov 1994 12:45:26 GMT
</PRE>

   The exact meaning of this header field depends on the implementation of the sender and the 
   nature of the original resource. For files, it may be just the file system last-modified time. For 
   entities with dynamically included parts, it may be the most recent of the set of last-modify 
   times for its component parts. For database gateways, it may be the last-update timestamp of 
   the record. For virtual objects, it may be the last time the internal state changed.
<P>

   An origin server must not send a Last-Modified date which is later than the server's time of 
   message origination. In such cases, where the resource's last modification would indicate some 
   time in the future, the server must replace that date with the message origination date.
<P>

<H3>8.11  <A NAME="Location">Location</A></H3>

   The Location response header field defines the exact location of the resource that was identified 
   by the <CODE>Request-URI</CODE>. For 3xx responses, the location must indicate the server's preferred URL 
   for automatic redirection to the resource. Only one absolute URL is allowed.
<P>

<PRE>
       Location       = "Location" ":" absoluteURI
</PRE>

   An example is
<P>

<PRE>
       Location: http://www.w3.org/hypertext/WWW/NewLocation.html
</PRE>

<H3>8.12  <A NAME="MIME-Version">MIME-Version</A></H3>

   HTTP is not a MIME-conformant protocol (see <A HREF="#MIME">Appendix C</A>). However, HTTP/1.0 messages 
   may include a single <CODE>MIME-Version</CODE> header field to indicate what version of the MIME protocol 
   was used to construct the message. Use of the <CODE>MIME-Version</CODE> header field should indicate that 
   the message is in full compliance with the MIME protocol (as defined in<A HREF="#54643"> [5]</A>). Unfortunately, 
   current versions of HTTP/1.0 clients and servers use this field indiscriminately, and thus 
   receivers must not take it for granted that the message is indeed in full compliance with MIME. 
   Gateways are responsible for ensuring this compliance (where possible) when exporting HTTP 
   messages to strict MIME environments. Future HTTP/1.0 applications must only use <CODE>MIME-Version</CODE>
   when the message is intended to be MIME-conformant.
<P>

<PRE>
       MIME-Version   = "MIME-Version" ":" 1*DIGIT "." 1*DIGIT
</PRE>

   MIME version "<CODE>1.0</CODE>" is the default for use in HTTP/1.0. However, HTTP/1.0 message parsing 
   and semantics are defined by this document and not the MIME specification.
<P>

<H3>8.13  <A NAME="Pragma">Pragma</A></H3>

   The <CODE>Pragma</CODE> message header field is used to include implementation-specific directives that 
   may apply to any recipient along the request/response chain. The directives typically specify 
   behavior intended to prevent intermediate proxies or caches from adversely interfering with the 
   request or response. All pragma directives specify optional behavior from the viewpoint of the 
   protocol; however, some systems may require that behavior be consistent with the directives. 
   HTTP/1.0 only defines semantics for the "<CODE>no-cache</CODE>" directive on request messages.
<P>

<PRE>
       Pragma           = "Pragma" ":" 1#pragma-directive
</PRE>

<PRE>
       pragma-directive = "no-cache" | extension-pragma
       extension-pragma = token [ "=" word ]
</PRE>

   When the "<CODE>no-cache</CODE>" directive is present in a request message, a caching intermediary should 
   forward the request toward the origin server even if it has a cached copy of what is being 
   requested. This allows a client to insist upon receiving an authoritative response to its request. 
   It also allows a client to refresh a cached copy which is known to be corrupted or stale.
<P>

   Pragma directives must be passed through by a proxy, regardless of their significance to that 
   proxy, since the directives may be applicable to all recipients along the request/response chain. 
   It is not possible to specify a pragma for a specific recipient; however, any pragma directive not 
   relevant to a recipient should be ignored by that recipient.
<P>

<H3>8.14  <A NAME="Referer">Referer</A></H3>

   The <CODE>Referer</CODE> request header field allows the client to specify, for the server's benefit, the address 
   (URI) of the resource from which the <CODE>Request-URI</CODE> was obtained. This allows a server to 
   generate lists of back-links to resources for interest, logging, optimized caching, etc. It also 
   allows obsolete or mistyped links to be traced for maintenance. The <CODE>Referer</CODE> field must not be 
   sent if the <CODE>Request-URI</CODE> was obtained from a source that does not have its own URI, such as input 
   from the user keyboard.
<P>

<PRE>
       Referer        = "Referer" ":" ( absoluteURI | relativeURI )
</PRE>

   Example:
<P>

<PRE>
       Referer: http://www.w3.org/hypertext/DataSources/Overview.html
</PRE>

   If a partial URI is given, it should be interpreted relative to the <CODE>Request-URI</CODE>. The URI must not 
   include a fragment.
<P>

<BLOCKQUOTE>
       Note: Because the source of a link may be private information or may reveal an 
       otherwise private information source, it is strongly recommended that the user be 
       able to select whether or not the <CODE>Referer</CODE> field is sent. For example, a browser client 
       could have a toggle switch for browsing openly/anonymously, which would 
       respectively enable/disable the sending of <CODE>Referer</CODE> and <CODE>From</CODE> information.
</BLOCKQUOTE>

<H3>8.15  <A NAME="Server">Server</A></H3>

   The <CODE>Server</CODE> response header field contains information about the software used by the origin 
   server to handle the request. The field can contain multiple product tokens (<A HREF="#Product">Section 3.7</A>) and 
   comments identifying the server and any significant subproducts. By convention, the product 
   tokens are listed in order of their significance for identifying the application.
<P>

<PRE>
       Server         = "Server" ":" 1*( product | comment )
</PRE>

   Example:
<P>

<PRE>
       Server: CERN/3.0 libwww/2.17
</PRE>

   If the response is being forwarded through a proxy, the proxy application should not add its data 
   to the product list.
<P>

<BLOCKQUOTE>
       Note: Revealing the specific software version of the server may allow the server 
       machine to become more vulnerable to attacks against software that is known to 
       contain security holes. Server implementors are encouraged to make this field a 
       configurable option.
</BLOCKQUOTE>

<H3>8.16  <A NAME="User-Agent">User-Agent</A></H3>

   The <CODE>User-Agent</CODE> field contains information about the user agent originating the request. This is 
   for statistical purposes, the tracing of protocol violations, and automated recognition of user 
   agents for the sake of tailoring responses to avoid particular user agent limitations. Although it 
   is not required, user agents should always include this field with requests. The field can contain 
   multiple product tokens (<A HREF="#Product">Section 3.7</A>) and comments identifying the agent and any subproducts 
   which form a significant part of the user agent. By convention, the product tokens are listed in 
   order of their significance for identifying the application.
<P>

<PRE>
       User-Agent     = "User-Agent" ":" 1*( product | comment )
</PRE>

   Example:
<P>

<PRE>
       User-Agent: CERN-LineMode/2.15 libwww/2.17b3
</PRE>

   The User-Agent field may include additional information within comments.
<P>

<BLOCKQUOTE>
       Note: Some current proxy applications append their product information to the list in 
       the User-Agent field. This is not recommended, since it makes machine interpretation 
       of these fields ambiguous.
</BLOCKQUOTE>

<H3>8.17  <A NAME="WWW-Authenticate">WWW-Authenticate</A></H3>

   The <CODE>WWW-Authenticate</CODE> header field must be included in 401 (unauthorized) response messages. 
   The field value consists of at least one <CODE>challenge</CODE> that indicates the authentication scheme(s) and 
   parameters applicable to the <CODE>Request-URI</CODE>.
<P>

<PRE>
       WWW-Authenticate = "WWW-Authenticate" ":" 1#challenge
</PRE>

   The HTTP access authentication process is described in <A HREF="#AA">Section 9</A>. User agents must take 
   special care in parsing the <CODE>WWW-Authenticate</CODE> field value if it contains more than one challenge, 
   or if more than one <CODE>WWW-Authenticate</CODE> header field is provided, since the contents of a challenge 
   may itself contain a comma-separated list of authentication parameters.
<P>

<H2>9.  <A NAME="AA">Access Authentication</A></H2>

   HTTP provides a simple challenge-response authentication mechanism which may be used by 
   a server to challenge a client request and by a client to provide authentication information. It 
   uses an extensible, case-insensitive token to identify the authentication scheme, followed by a 
   comma-separated list of attribute-value pairs which carry the parameters necessary for 
   achieving authentication via that scheme.
<P>

<PRE>
       auth-scheme    = token
</PRE>

<PRE>
       auth-param     = token "=" quoted-string
</PRE>

   The 401 (unauthorized) response message is used by an origin server to challenge the 
   authorization of a user agent. This response must include a <CODE>WWW-Authenticate</CODE> header field 
   containing at least one <CODE>challenge</CODE> applicable to the requested resource.
<P>

<PRE>
       challenge      = auth-scheme 1*SP realm *( "," auth-param )
</PRE>

<PRE>
       realm          = "realm" "=" realm-value
       realm-value    = quoted-string
</PRE>

   The realm attribute (case-insensitive) is required for all authentication schemes which issue a 
   challenge. The realm value (case-sensitive), in combination with the canonical root URL of the 
   server being accessed, defines the protection space. These realms allow the protected resources 
   on a server to be partitioned into a set of protection spaces, each with its own authentication 
   scheme and/or authorization database. The realm value is a string, generally assigned by the 
   origin server, which may have additional semantics specific to the authentication scheme.
<P>

   A user agent that wishes to authenticate itself with a server--usually, but not necessarily, after 
   receiving a 401 response--may do so by including an <CODE>Authorization</CODE> header field with the 
   request. The <CODE>Authorization</CODE> field value consists of <CODE>credentials</CODE> containing the authentication 
   information of the user agent for the realm of the resource being requested.
<P>

<PRE>
       credentials    = basic-credentials
                      | ( auth-scheme #auth-param )
</PRE>

   The domain over which credentials can be automatically applied by a user agent is determined 
   by the protection space. If a prior request has been authorized, the same credentials may be 
   reused for all other requests within that protection space for a period of time determined by the 
   authentication scheme, parameters, and/or user preference. Unless otherwise defined by the 
   authentication scheme, a single protection space cannot extend outside the scope of its server.
<P>

   If the server does not wish to accept the credentials sent with a request, it should return a 403 
   (forbidden) response.
<P>

   The HTTP protocol does not restrict applications to this simple challenge-response mechanism 
   for access authentication. Additional mechanisms may be used at the transport level, via 
   message encapsulation, and/or with additional header fields specifying authentication 
   information. However, these additional mechanisms are not defined by this specification.
<P>

   Proxies must be completely transparent regarding user agent authentication. That is, they must 
   forward the <CODE>WWW-Authenticate</CODE> and <CODE>Authorization</CODE> headers untouched, and must not cache the 
   response to a request containing <CODE>Authorization</CODE>. HTTP/1.0 does not provide a means for a client 
   to be authenticated with a proxy.
<P>

<H3>9.1  <A NAME="BasicAA">Basic Authentication Scheme</A></H3>

   The "basic" authentication scheme is based on the model that the user agent must authenticate 
   itself with a user-ID and a password for each realm. The realm value should be considered an 
   opaque string which can only be compared for equality with other realms on that server. The 
   server will authorize the request only if it can validate the user-ID and password for the 
   protection space of the <CODE>Request-URI</CODE>. There are no optional authentication parameters.
<P>

   Upon receipt of an unauthorized request for a URI within the protection space, the server 
   should respond with a challenge like the following:
<P>

<PRE>
       WWW-Authenticate: Basic realm="WallyWorld"
</PRE>

   where "WallyWorld" is the string assigned by the server to identify the protection space of the 
   <CODE>Request-URI</CODE>.
<P>

   To receive authorization, the client sends the user-ID and password, separated by a single colon 
   (":") character, within a base64<A HREF="#54643"> [5]</A> encoded string in the <CODE>credentials</CODE>.
<P>

<PRE>
       basic-credentials = "Basic" SP basic-cookie
</PRE>

<PRE>
       basic-cookie      = &lt;base64<A HREF="#54643"> [5]</A> encoding of userid-password,
                            except not limited to 76 char/line&gt;
</PRE>

<PRE>
       userid-password   = [ token ] ":" *text
</PRE>

   If the user agent wishes to send the user-ID "Aladdin" and password "open sesame", it would 
   use the following header field:
<P>

<PRE>
       Authorization: Basic QWxhZGRpbjpvcGVuIHNlc2FtZQ==
</PRE>

   The basic authentication scheme is a non-secure method of filtering unauthorized access to 
   resources on an HTTP server. It is based on the assumption that the connection between the 
   client and the server can be regarded as a trusted carrier. As this is not generally true on an open 
   network, the basic authentication scheme should be used accordingly. In spite of this, clients 
   are encouraged to implement the scheme in order to communicate with servers that use it.
<P>

<H2>10.  <A NAME="Security">Security Considerations</A></H2>

   This section is meant to inform application developers, information providers, and users of the 
   security limitations in HTTP/1.0 as described by this document. The discussion does not 
   include definitive solutions to the problems revealed, though it does make some suggestions for 
   reducing security risks.
<P>

<H3>10.1  <A NAME="AuthSecurity">Authentication of Clients</A></H3>

   As mentioned in <A HREF="#BasicAA">Section 9.1</A>, the Basic authentication scheme is not a secure method of user 
   authentication, nor does it prevent the <CODE>Entity-Body</CODE> from being transmitted in clear text across the 
   physical network used as the carrier. HTTP/1.0 does not prevent additional authentication 
   schemes and encryption mechanisms from being employed to increase security.
<P>

<H3>10.2  <A NAME="SafeMethods">Safe Methods</A></H3>

   The writers of client software should be aware that the software represents the user in their 
   interactions over the Internet, and should be careful to allow the user to be aware of any actions 
   they may take which may have an unexpected significance to themselves or others.
<P>

   In particular, the convention has been established that the <CODE>GET</CODE> and <CODE>HEAD</CODE> methods should never 
   have the significance of taking an action other than retrieval. These methods should be 
   considered "safe." This allows user agents to represent other methods, such as <CODE>POST</CODE>, in a 
   special way, so that the user is made aware of the fact that a possibly unsafe action is being 
   requested.
<P>

   Naturally, it is not possible to ensure that the server does not generate side-effects as a result of 
   performing a <CODE>GET</CODE> request; in fact, some dynamic resources consider that a feature. The 
   important distinction here is that the user did not request the side-effects, so therefore cannot 
   be held accountable for them.
<P>

<H3>10.3  <A NAME="LogAbuse">Abuse of Server Log Information</A></H3>

   A server is in the position to save personal data about a user's requests which may identify their 
   reading patterns or subjects of interest. This information is clearly confidential in nature and its 
   handling may be constrained by law in certain countries. People using the HTTP protocol to 
   provide data are responsible for ensuring that such material is not distributed without the 
   permission of any individuals that are identifiable by the published results.
<P>

<H3>10.4  <A NAME="Sensitive">Transfer of Sensitive Information</A></H3>

   Like any generic data transfer protocol, HTTP cannot regulate the content of the data that is 
   transferred, nor is there any a priori method of determining the sensitivity of any particular 
   piece of information within the context of any given request. Therefore, applications are 
   encouraged to supply as much control over this information as possible to the provider of that 
   information. Three header fields are worth special mention in this context: <CODE>Server</CODE>, <CODE>Referer</CODE> and 
   <CODE>From</CODE>.
<P>

   Revealing the specific software version of the server may allow the server machine to become 
   more vulnerable to attacks against software that is known to contain security holes. 
   Implementors are encouraged to make the <CODE>Server</CODE> header field a configurable option.
<P>

   The <CODE>Referer</CODE> field allows reading patterns to be studied and reverse links drawn. Although it can 
   be very useful, its power can be abused if user details are not separated from the information 
   contained in the <CODE>Referer</CODE>. Even when the personal information has been removed, the <CODE>Referer</CODE> 
   field may indicate a private document's URI whose publication would be inappropriate.
<P>

   The information sent in the <CODE>From</CODE> field might conflict with the user's privacy interests or their 
   site's security policy, and hence it should not be transmitted without the user being able to 
   disable, enable, and modify the contents of the field. The user must be able to set the contents 
   of this field within a user preference or application defaults configuration.
<P>

   We suggest, though do not require, that a convenient toggle interface be provided for the user 
   to enable or disable the sending of <CODE>From</CODE> and <CODE>Referer</CODE> information.
<P>

<H2>11.  <A NAME="Acknowledgments">Acknowledgments</A></H2>

   This specification makes heavy use of the augmented BNF and generic constructs defined by 
   David H. Crocker for RFC 822<A HREF="#96313"> [7]</A>. Similarly, it reuses many of the definitions provided by 
   Nathaniel Borenstein and Ned Freed for MIME<A HREF="#54643"> [5]</A>. We hope that their inclusion in this 
   specification will help reduce past confusion over the relationship between HTTP/1.0 and 
   Internet mail message formats.
<P>

   The HTTP protocol has evolved considerably over the past three years. It has benefited from a 
   large and active developer community--the many people who have participated on the 
   <EM>www-talk</EM> mailing list--and it is that community which has been most responsible for the 
   success of HTTP and of the World-Wide Web in general. Marc Andreessen, Robert Cailliau, 
   Daniel W. Connolly, Bob Denny, Jean Francois-Groff, Phillip M. Hallam-Baker, H&aring;kon W. Lie, 
   Ari Luotonen, Rob McCool, Lou Montulli, Dave Raggett, Tony Sanders, and 
   Marc VanHeyningen deserve special recognition for their efforts in defining aspects of the 
   protocol for early versions of this specification.
<P>

   This document has benefited greatly from the comments of all those participating in the 
   HTTP-WG. In addition to those already mentioned, the following individuals have contributed 
   to this specification:
<P>

<PRE>
       Gary Adams                         Harald Tveit Alvestrand
       Keith Ball                         Brian Behlendorf
       Paul Burchard                      Maurizio Codogno
       Mike Cowlishaw                     Roman Czyborra
       Michael A. Dolan                   John Franks
       Jim Gettys                         Marc Hedlund
       Koen Holtman                       Alex Hopmann
       Bob Jernigan                       Shel Kaphan
       Martijn Koster                     Dave Kristol
       Daniel LaLiberte                   Paul Leach
       Albert Lunde                       John C. Mallery
       Larry Masinter                     Mitra
       Gavin Nicol                        Bill Perry
       Jeffrey Perry                      Owen Rees
       David Robinson                     Marc Salomon
       Rich Salz                          Jim Seidman
       Chuck Shotton                      Eric W. Sink
       Simon E. Spero                     Robert S. Thau
       Fran&ccedil;ois Yergeau                   Mary Ellen Zurko
</PRE>

<H2>12. <A NAME="References">References</A></H2>

<DL COMPACT>
<DT>[1]
<DD><A NAME="81090">F. Anklesaria,</A> M. McCahill, P. Lindner, D. Johnson,
D. Torrey, and B. Alberti. "The Internet Gopher Protocol: A distributed
document search and retrieval protocol."
<A HREF="http://ds.internic.net/rfc/rfc1436.txt>RFC 1436</A>,
University of Minnesota, March 1993.
<p>
<DT>[2]
<DD><A NAME="70197">T. Berners-Lee.</A> "Universal Resource Identifiers in WWW:
A Unifying Syntax for the Expression of Names and Addresses of Objects on
the Network as used in the World-Wide Web."
<A HREF="http://ds.internic.net/rfc/rfc1630.txt>RFC 1630</A>, CERN, June 1994.
<p>
<DT>[3]
<DD><A NAME="46155">T. Berners-Lee and D. Connolly.</A>
"HyperText Markup Language Specification - 2.0."
<A HREF="http://www.ics.uci.edu/pub/ietf/html/">Work in Progress</A>
(draft-ietf-html-spec-05.txt), MIT/W3C, August 1995.
<p>
<DT>[4]
<DD><A NAME="70760">T. Berners-Lee,</A> L. Masinter, and M. McCahill.
"Uniform Resource Locators (URL)."
<A HREF="http://ds.internic.net/rfc/rfc1738.txt>RFC 1738</A>,
CERN, Xerox PARC, University of Minnesota, December 1994.
<p>
<DT>[5]
<DD><A NAME="54643">N. Borenstein</A> and N. Freed.
"MIME (Multipurpose Internet Mail Extensions) Part One: Mechanisms for
Specifying and Describing the Format of Internet Message Bodies."
<A HREF="http://ds.internic.net/rfc/rfc1521.txt>RFC 1521</A>,
Bellcore, Innosoft, September 1993.
<p>
<DT>[6]
<DD><A NAME="40086">R. Braden.</A>
"Requirements for Internet hosts - application and support."
<A HREF="http://ds.internic.net/std/std3.txt">STD 3</A>,
RFC 1123, IETF, October 1989.
<p>
<DT>[7]
<DD><A NAME="96313">D. H. Crocker.</A>
"Standard for the Format of ARPA Internet Text Messages."
<A HREF="http://ds.internic.net/std/std11.txt">STD 11</A>,
RFC 822, UDEL, August 1982.
<p>
<DT>[8]
<DD><A NAME="21509">F. Davis, B. Kahle, H. Morris, J. Salem, T. Shen,
R. Wang, J. Sui, and M. Grinbaum.</A>
"WAIS Interface Protocol Prototype Functional Specification." (v1.5), Thinking
Machines Corporation, April 1990.
<p>
<DT>[9]
<DD><A NAME="55040">R. Fielding.</A> "Relative Uniform Resource Locators."
<A HREF="http://ds.internic.net/rfc/rfc1808.txt>RFC 1808</A>, UC Irvine,
June 1995.
<p>
<DT>[10]
<DD><A NAME="29505">M. Horton and R. Adams.</A> "Standard for interchange
of USENET messages."
<A HREF="http://ds.internic.net/rfc/rfc1036.txt>RFC 1036</A>
(Obsoletes RFC 850), AT&amp;T Bell Laboratories, Center for Seismic Studies,
December 1987.
<p>
<DT>[11]
<DD><A NAME="41656">B. Kantor and P. Lapsley.</A> "Network News Transfer
Protocol: A Proposed Standard for the Stream-Based Transmission of News."
<A HREF="http://ds.internic.net/rfc/rfc977.txt>RFC 977</A>,
UC San Diego, UC Berkeley, February 1986.
<p>
<DT>[12]
<DD><A NAME="67282">J. Postel.</A> "Simple Mail Transfer Protocol."
<A HREF="http://ds.internic.net/std/std10.txt>STD 10</A>, RFC 821,
USC/ISI, August 1982.</A>
<p>
<DT>[13]
<DD><A NAME="35139">J. Postel.</A> "Media Type Registration Procedure."
<A HREF="http://ds.internic.net/rfc/rfc1590.txt>RFC 1590</a>,
USC/ISI, March 1994.
<p>
<DT>[14]
<DD><A NAME="94364">J. Postel and J. K. Reynolds.</A>
"File Transfer Protocol (FTP)."
<A HREF="http://ds.internic.net/std/std9.txt>STD 9</A>,
RFC 959, USC/ISI, October 1985.
<p>
<DT>[15]
<DD><A NAME="22085">J. Reynolds and J. Postel.</A> "Assigned Numbers."
<A HREF="http://ds.internic.net/std/std2.txt">STD 2</A>, RFC 1700, USC/ISI,
October 1994.
<p>
<DT>[16]
<DD><A NAME="15237">K. Sollins and L. Masinter.</A> "Functional Requirements for
Uniform Resource Names." <A HREF="http://ds.internic.net/rfc/rfc1737.txt>
RFC 1737</A>, MIT/LCS, Xerox Corporation, December 1994.
<p>
<DT>[17]
<DD><A NAME="29693">US-ASCII.</A> Coded Character Set - 7-Bit American Standard
Code for Information Interchange. Standard ANSI X3.4-1986, ANSI, 1986.
<p>
<DT>[18]
<DD><A NAME="75289">ISO-8859.</A> International Standard -- Information
Processing -- 8-bit Single-Byte Coded Graphic Character Sets --
Part 1: Latin Alphabet No. 1, ISO 8859-1:1987.
Part 2: Latin alphabet No. 2, ISO 8859-2, 1987.
Part 3: Latin alphabet No. 3, ISO 8859-3, 1988.
Part 4: Latin alphabet No. 4, ISO 8859-4, 1988.
Part 5: Latin/Cyrillic alphabet, ISO 8859-5, 1988.
Part 6: Latin/Arabic alphabet, ISO 8859-6, 1987.
Part 7: Latin/Greek alphabet, ISO 8859-7, 1987.
Part 8: Latin/Hebrew alphabet, ISO 8859-8, 1988.
Part 9: Latin alphabet No. 5, ISO 8859-9, 1990.
</DL>

<H2>13.  <A NAME="Authors">Authors' Addresses</A></H2>

   <STRONG>Tim Berners-Lee</STRONG><BR>
   Director, W3 Consortium<BR>
   MIT Laboratory for Computer Science<BR>
   545 Technology Square<BR>
   Cambridge, MA 02139, U.S.A.<BR>
   Tel: +1 (617) 253 5702<BR>
   Fax: +1 (617) 258 8682<BR>
   Email: timbl@w3.org
<P>

   <STRONG>Roy T. Fielding</STRONG><BR>
   Department of Information and Computer Science<BR>
   University of California<BR>
   Irvine, CA 92717-3425, U.S.A.<BR>
   Tel: +1 (714) 824-4049<BR>
   Fax: +1 (714) 824-4056<BR>
   Email: fielding@ics.uci.edu
<P>

   <STRONG>Henrik Frystyk Nielsen</STRONG><BR>
   W3 Consortium<BR>
   MIT Laboratory for Computer Science<BR>
   545 Technology Square<BR>
   Cambridge, MA 02139, U.S.A.<BR>
   Tel: +1 (617) 258 8143<BR>
   Fax: +1 (617) 258 8682<BR>
   Email: frystyk@w3.org
<P>

<H2><A NAME="Appendices">Appendices</A></H2>

   These appendices are provided for informational reasons only -- they do not form a part of the 
   HTTP/1.0 specification.
<P>

<H2>A.  <A NAME="message_http">Internet Media Type message/http</A></H2>

   In addition to defining the HTTP/1.0 protocol, this document serves as the specification for the 
   Internet media type "message/http". The following is to be registered with IANA<A HREF="#35139"> [13]</A>.
<P>

<PRE>
       Media Type name:         message

       Media subtype name:      http

       Required parameters:     none

       Optional parameters:     version, msgtype

              version: The HTTP-Version number of the enclosed message 
                       (e.g., "1.0"). If not present, the version can be 
                       determined from the first line of the body.

              msgtype: The message type -- "request" or "response". If not 
                       present, the type can be determined from the first 
                       line of the body.

       Encoding considerations: only "7bit", "8bit", or "binary" are 
                                permitted

       Security considerations: none
</PRE>

<H2>B.  <A NAME="Tolerant">Tolerant Applications</A></H2>

   Although this document specifies the requirements for the generation of HTTP/1.0 messages, 
   not all applications will be correct in their implementation. We therefore recommend that 
   operational applications be tolerant of deviations whenever those deviations can be interpreted 
   unambiguously.
<P>

   Clients should be tolerant in parsing the <CODE>StatusLine</CODE> and servers tolerant when parsing the 
   <CODE>RequestLine</CODE>. In particular, they should accept any amount of <CODE>SP</CODE> or <CODE>HT</CODE> characters between fields, 
   even though only a single <CODE>SP</CODE> is required.
<P>

   The line terminator for <CODE>HTTP-header</CODE> fields is the sequence <CODE>CRLF</CODE>. However, we recommend that 
   applications, when parsing such headers, recognize a single <CODE>LF</CODE> as a line terminator and ignore 
   the leading <CODE>CR</CODE>.
<P>

<H2>C.  <A NAME="MIME">Relationship to MIME</A></H2>

   HTTP/1.0 reuses many of the constructs defined for Internet Mail (RFC 822<A HREF="#96313"> [7]</A>) and the 
   Multipurpose Internet Mail Extensions (MIME<A HREF="#54643"> [5]</A>) to allow entities to be transmitted in an 
   open variety of representations and with extensible mechanisms. However, HTTP is not a 
   MIME-conforming application. HTTP's performance requirements differ substantially from 
   those of Internet mail. Since it is not limited by the restrictions of existing mail protocols and 
   gateways, HTTP does not obey some of the constraints imposed by RFC 822 and MIME for 
   mail transport.
<P>

   This appendix describes specific areas where HTTP differs from MIME. Gateways to MIME-compliant
   protocols must be aware of these differences and provide the appropriate 
   conversions where necessary.
<P>

<H3>C.1  <A NAME="MIME-Canonical">Conversion to Canonical Form</A></H3>

   MIME requires that an entity be converted to canonical form prior to being transferred, as 
   described in Appendix G of RFC 1521<A HREF="#54643"> [5]</A>. Although HTTP does require media types to be 
   transferred in canonical form, it changes the definition of "canonical form" for text-based 
   media types as described in <A HREF="#TextCanonicalization">Section 3.6.1</A>.
<P>

<H4>C.1.1 <A NAME="MIME-LineBreaks">Representation of Line Breaks</A></H4>

   MIME requires that the canonical form of any text type represent line breaks as <CODE>CRLF</CODE> and 
   forbids the use of <CODE>CR</CODE> or <CODE>LF</CODE> outside of line break sequences. Since HTTP allows <CODE>CRLF</CODE>, bare <CODE>CR</CODE>, 
   and bare <CODE>LF</CODE> (or the octet sequence(s) to which they would be translated for the given character 
   set) to indicate a line break within text content, recipients of an HTTP message cannot rely 
   upon receiving MIME-canonical line breaks in text.
<P>

   Where it is possible, a gateway from HTTP to a MIME-conformant protocol should translate 
   all line breaks within text/* media types to the MIME canonical form of <CODE>CRLF</CODE>. However, this 
   may be complicated by the presence of a Content-Encoding and by the fact that HTTP allows 
   the use of some character sets which do not use octets 13 and 10 to represent <CODE>CR</CODE> and <CODE>LF</CODE>, as is 
   the case for some multi-byte character sets. If canonicalization is performed, the
   Content-Length header field value must be updated to reflect the new body length.
<P>

<H4>C.1.2 <A NAME="MIME-Charset">Default Character Set</A></H4>

   MIME requires that all subtypes of the top-level Content-Type "text" have a default character 
   set of US-ASCII<A HREF="#29693"> [17]</A>. In contrast, HTTP defines the default character set for "text" to be 
   ISO-8859-1<A HREF="#75289"> [18]</A> (a superset of US-ASCII). Therefore, if a text/* media type given in the 
   Content-Type header field does not already include an explicit charset parameter, the parameter
<P>

<PRE>
       ;charset="iso-8859-1"
</PRE>

   should be added by the gateway if the entity contains any octets greater than 127.
<P>

<H3>C.2  <A NAME="MIME-Date">Conversion of Date Formats</A></H3>

   HTTP/1.0 uses a restricted subset of date formats to simplify the process of date comparison. 
   Gateways from other protocols should ensure that any <CODE>Date</CODE> header field present in a message 
   conforms to one of the HTTP/1.0 formats and rewrite the date if necessary.
<P>

<H3>C.3  <A NAME="MIME-CT">Introduction of Content-Encoding</A></H3>

   MIME does not include any concept equivalent to HTTP's <CODE>Content-Encoding</CODE> header field. Since 
   this acts as a modifier on the media type, gateways to MIME-conformant protocols must either 
   change the value of the <CODE>Content-Type</CODE> header field or decode the <CODE>Entity-Body</CODE> before forwarding 
   the message.
<P>

<BLOCKQUOTE>
       Note: Some experimental applications of Content-Type for Internet mail have used a 
       media-type parameter of ";conversions=&lt;content-coding&gt;" to perform an 
       equivalent function as Content-Encoding. However, this parameter is not part of the 
       MIME specification at the time of this writing.
</BLOCKQUOTE>

<H3>C.4  <A NAME="MIME-CTE">No Content-Transfer-Encoding</A></H3>

   HTTP does not use the <CODE>Content-Transfer-Encoding</CODE> (CTE) field of MIME. Gateways from 
   MIME-compliant protocols must remove any non-identity CTE ("quoted-printable" or 
   "base64") encoding prior to delivering the response message to an HTTP client. Gateways to 
   MIME-compliant protocols are responsible for ensuring that the message is in the correct 
   format and encoding for safe transport on that protocol, where "safe transport" is defined by the 
   limitations of the protocol being used. At a minimum, the CTE field of
<P>

<PRE>
       Content-Transfer-Encoding: binary
</PRE>

   should be added by the gateway if it is unwilling to apply a content transfer encoding.
<P>

   An HTTP client may include a <CODE>Content-Transfer-Encoding</CODE> as an extension <CODE>Entity-Header</CODE> in a 
   <CODE>POST</CODE> request when it knows the destination of that request is a gateway to a MIME-compliant 
   protocol.
<P>


</BODY>
</HTML>
